; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: armcc [4d365d]
; commandline armcc [--c99 --list --split_sections --debug -c --asm --interleave -o..\Output\key.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\Output\key.d --cpu=Cortex-M0+ --apcs=interwork --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -D__UVISION_VERSION=536 -DSC32f12xx --omf_browse=..\Output\key.crf ..\HardDrive\key.c]
                          THUMB

                          AREA ||i.Key_IRQHandler||, CODE, READONLY, ALIGN=2

                  Key_IRQHandler PROC
;;;81       */
;;;82     void Key_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;83     {
;;;84         /* 清除中断标志 */
;;;85         INT_ClearFlag(Key_Handler.INT_Channel);
000002  4809              LDR      r0,|L1.40|
000004  88c0              LDRH     r0,[r0,#6]  ; Key_Handler
000006  f7fffffe          BL       INT_ClearFlag
;;;86         
;;;87         /* 读取当前按键状态 */
;;;88         Key_State current_state = Key_Read();
00000a  f7fffffe          BL       Key_Read
;;;89         
;;;90         /* 调用对应的回调函数 */
;;;91         if(current_state == KEY_PRESSED && PressCallback != 0) {
00000e  4907              LDR      r1,|L1.44|
000010  2801              CMP      r0,#1
000012  d006              BEQ      |L1.34|
;;;92             PressCallback();
;;;93         } else if(current_state == KEY_RELEASED && ReleaseCallback != 0) {
000014  2800              CMP      r0,#0
000016  d103              BNE      |L1.32|
000018  6848              LDR      r0,[r1,#4]  ; ReleaseCallback
                  |L1.26|
00001a  2800              CMP      r0,#0                 ;91
00001c  d000              BEQ      |L1.32|
;;;94             ReleaseCallback();
00001e  4780              BLX      r0
                  |L1.32|
;;;95         }
;;;96     }
000020  bd10              POP      {r4,pc}
                  |L1.34|
000022  6808              LDR      r0,[r1,#0]            ;91  ; PressCallback
000024  e7f9              B        |L1.26|
                          ENDP

000026  0000              DCW      0x0000
                  |L1.40|
                          DCD      ||.bss||
                  |L1.44|
                          DCD      ||.data||

                          AREA ||i.Key_Init||, CODE, READONLY, ALIGN=2

                  Key_Init PROC
;;;9        */
;;;10     void Key_Init(Key_InitTypeDef* Key_InitStruct)
000000  b57f              PUSH     {r0-r6,lr}
;;;11     {
;;;12         /* 保存配置 */
;;;13         Key_Handler.GPIOx = Key_InitStruct->GPIOx;
000002  4c17              LDR      r4,|L2.96|
000004  6802              LDR      r2,[r0,#0]
;;;14         Key_Handler.GPIO_Pin = Key_InitStruct->GPIO_Pin;
000006  6022              STR      r2,[r4,#0]  ; Key_Handler
000008  8881              LDRH     r1,[r0,#4]
00000a  80a1              STRH     r1,[r4,#4]
;;;15         Key_Handler.INT_Channel = Key_InitStruct->INT_Channel;
00000c  88c3              LDRH     r3,[r0,#6]
00000e  80e3              STRH     r3,[r4,#6]
;;;16         Key_Handler.INT_Port = Key_InitStruct->INT_Port;
000010  7a03              LDRB     r3,[r0,#8]
000012  7223              STRB     r3,[r4,#8]
;;;17         Key_Handler.ActiveLevel = Key_InitStruct->ActiveLevel;
000014  7a40              LDRB     r0,[r0,#9]
000016  7260              STRB     r0,[r4,#9]
;;;18         
;;;19         /* GPIO初始化 - 上拉输入模式 */
;;;20         GPIO_InitTypeDef GPIO_InitStructure;
;;;21         GPIO_InitStructure.GPIO_Pin = Key_Handler.GPIO_Pin;
000018  466b              MOV      r3,sp
00001a  8119              STRH     r1,[r3,#8]
;;;22         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_PU;  // 上拉输入
00001c  2501              MOVS     r5,#1
00001e  815d              STRH     r5,[r3,#0xa]
;;;23         GPIO_InitStructure.GPIO_DriveLevel = GPIO_DriveLevel_0;
000020  2000              MOVS     r0,#0
000022  8198              STRH     r0,[r3,#0xc]
;;;24         GPIO_Init(Key_Handler.GPIOx, &GPIO_InitStructure);
000024  a902              ADD      r1,sp,#8
000026  4610              MOV      r0,r2
000028  f7fffffe          BL       GPIO_Init
;;;25         
;;;26         /* 外部中断初始化 */
;;;27         INT_InitTypeDef INT_InitStructure;
;;;28         INT_InitStructure.INT_Channel = Key_Handler.INT_Channel;
00002c  88e0              LDRH     r0,[r4,#6]  ; Key_Handler
00002e  466b              MOV      r3,sp
000030  8018              STRH     r0,[r3,#0]
;;;29         INT_InitStructure.INT_INTSEL = Key_Handler.INT_Port;
000032  7a20              LDRB     r0,[r4,#8]  ; Key_Handler
000034  8098              STRH     r0,[r3,#4]
;;;30         
;;;31         /* 根据有效电平配置触发方式 */
;;;32         if(Key_Handler.ActiveLevel == KEY_PRESSED) {
000036  7a60              LDRB     r0,[r4,#9]  ; Key_Handler
000038  2801              CMP      r0,#1
00003a  d00c              BEQ      |L2.86|
;;;33             // 按下为低电平：下降沿触发
;;;34             INT_InitStructure.INT_Trigger = INT_Trigger_Falling;
;;;35         } else {
;;;36             // 按下为高电平：上升沿触发
;;;37             INT_InitStructure.INT_Trigger = INT_Trigger_Rising;
00003c  805d              STRH     r5,[r3,#2]
                  |L2.62|
;;;38         }
;;;39         
;;;40         INT_Init(&INT_InitStructure);
00003e  4618              MOV      r0,r3
000040  f7fffffe          BL       INT_Init
;;;41         
;;;42         /* 使能外部中断 */
;;;43         INT_ITConfig(Key_Handler.INT_Channel, 
000044  7a60              LDRB     r0,[r4,#9]  ; Key_Handler
000046  2801              CMP      r0,#1
000048  d008              BEQ      |L2.92|
;;;44                      (Key_Handler.ActiveLevel == KEY_PRESSED) ? INT_IT_Falling : INT_IT_Rising, 
00004a  2101              MOVS     r1,#1
                  |L2.76|
00004c  88e0              LDRH     r0,[r4,#6]  ; Key_Handler
00004e  2201              MOVS     r2,#1
000050  f7fffffe          BL       INT_ITConfig
;;;45                      ENABLE);
;;;46     }
000054  bd7f              POP      {r0-r6,pc}
                  |L2.86|
000056  2002              MOVS     r0,#2                 ;34
000058  8058              STRH     r0,[r3,#2]            ;34
00005a  e7f0              B        |L2.62|
                  |L2.92|
00005c  2102              MOVS     r1,#2                 ;44
00005e  e7f5              B        |L2.76|
;;;47     
                          ENDP

                  |L2.96|
                          DCD      ||.bss||

                          AREA ||i.Key_Read||, CODE, READONLY, ALIGN=2

                  Key_Read PROC
;;;50       */
;;;51     Key_State Key_Read(void)
000000  b510              PUSH     {r4,lr}
;;;52     {
;;;53         BitAction pin_state = GPIO_ReadDataBit(Key_Handler.GPIOx, Key_Handler.GPIO_Pin);
000002  4c0a              LDR      r4,|L3.44|
000004  88a1              LDRH     r1,[r4,#4]  ; Key_Handler
000006  6820              LDR      r0,[r4,#0]  ; Key_Handler
000008  f7fffffe          BL       GPIO_ReadDataBit
;;;54         
;;;55         if((pin_state == SET && Key_Handler.ActiveLevel == KEY_PRESSED) ||
00000c  2801              CMP      r0,#1
00000e  d002              BEQ      |L3.22|
;;;56            (pin_state == RESET && Key_Handler.ActiveLevel == KEY_RELEASED)) {
000010  2800              CMP      r0,#0
000012  d004              BEQ      |L3.30|
000014  e006              B        |L3.36|
                  |L3.22|
000016  7a60              LDRB     r0,[r4,#9]            ;55  ; Key_Handler
000018  2801              CMP      r0,#1                 ;55
00001a  d005              BEQ      |L3.40|
00001c  e002              B        |L3.36|
                  |L3.30|
00001e  7a60              LDRB     r0,[r4,#9]  ; Key_Handler
000020  2800              CMP      r0,#0
000022  d001              BEQ      |L3.40|
                  |L3.36|
;;;57             return KEY_RELEASED;
;;;58         } else {
;;;59             return KEY_PRESSED;
000024  2001              MOVS     r0,#1
;;;60         }
;;;61     }
000026  bd10              POP      {r4,pc}
                  |L3.40|
000028  2000              MOVS     r0,#0                 ;57
00002a  bd10              POP      {r4,pc}
;;;62     
                          ENDP

                  |L3.44|
                          DCD      ||.bss||

                          AREA ||i.Key_SetPressCallback||, CODE, READONLY, ALIGN=2

                  Key_SetPressCallback PROC
;;;65       */
;;;66     void Key_SetPressCallback(Key_Callback callback)
000000  4901              LDR      r1,|L4.8|
;;;67     {
;;;68         PressCallback = callback;
000002  6008              STR      r0,[r1,#0]  ; PressCallback
;;;69     }
000004  4770              BX       lr
;;;70     
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      ||.data||

                          AREA ||i.Key_SetReleaseCallback||, CODE, READONLY, ALIGN=2

                  Key_SetReleaseCallback PROC
;;;73       */
;;;74     void Key_SetReleaseCallback(Key_Callback callback)
000000  4901              LDR      r1,|L5.8|
;;;75     {
;;;76         ReleaseCallback = callback;
000002  6048              STR      r0,[r1,#4]  ; ReleaseCallback
;;;77     }
000004  4770              BX       lr
;;;78     
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Key_Handler
                          %        12

                          AREA ||.data||, DATA, ALIGN=2

                  PressCallback
                          DCD      0x00000000
                  ReleaseCallback
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\HardDrive\\key.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_key_c_Key_Init____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___5_key_c_Key_Init____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_key_c_Key_Init____REVSH|
#line 478
|__asm___5_key_c_Key_Init____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
