; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: armcc [4d365d]
; commandline armcc [--c99 --list --split_sections --debug -c --asm --interleave -o..\Output\key.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\Output\key.d --cpu=Cortex-M0+ --apcs=interwork --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\HardDrive -I..\Application -D__UVISION_VERSION=536 -DSC32f12xx --omf_browse=..\Output\key.crf ..\HardDrive\key.c]
                          THUMB

                          AREA ||i.Key_IRQHandler||, CODE, READONLY, ALIGN=2

                  Key_IRQHandler PROC
;;;94       */
;;;95     void Key_IRQHandler(Key_ID keyId)
000000  b570              PUSH     {r4-r6,lr}
;;;96     {
000002  4604              MOV      r4,r0
;;;97     	if(keyId >= Key_Handler.keyCount) return;
000004  480d              LDR      r0,|L1.60|
000006  7e00              LDRB     r0,[r0,#0x18]  ; Key_Handler
000008  42a0              CMP      r0,r4
00000a  d913              BLS      |L1.52|
;;;98     	
;;;99         /* 清除中断标志 */
;;;100        INT_ClearFlag(Key_Handler.config[keyId].INT_Channel);
00000c  4d0b              LDR      r5,|L1.60|
00000e  200c              MOVS     r0,#0xc
000010  4360              MULS     r0,r4,r0
000012  3d20              SUBS     r5,r5,#0x20
000014  1940              ADDS     r0,r0,r5
000016  88c0              LDRH     r0,[r0,#6]
000018  f7fffffe          BL       INT_ClearFlag
;;;101        
;;;102        /* 读取当前按键状态 */
;;;103        Key_State current_state = Key_Read(keyId);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       Key_Read
;;;104        
;;;105        /* 调用对应的回调函数 */
;;;106        if(current_state == KEY_PRESSED && Key_Handler.PressCallback != 0) {
000022  2801              CMP      r0,#1
000024  d007              BEQ      |L1.54|
;;;107            Key_Handler.PressCallback(keyId);
;;;108        } else if(current_state == KEY_RELEASED && Key_Handler.ReleaseCallback != 0) {
000026  2800              CMP      r0,#0
000028  d104              BNE      |L1.52|
00002a  6b69              LDR      r1,[r5,#0x34]  ; Key_Handler
                  |L1.44|
00002c  2900              CMP      r1,#0                 ;106
00002e  d001              BEQ      |L1.52|
;;;109            Key_Handler.ReleaseCallback(keyId);
000030  4620              MOV      r0,r4
000032  4788              BLX      r1
                  |L1.52|
;;;110        }
;;;111    }
000034  bd70              POP      {r4-r6,pc}
                  |L1.54|
000036  6b29              LDR      r1,[r5,#0x30]         ;106  ; Key_Handler
000038  e7f8              B        |L1.44|
                          ENDP

00003a  0000              DCW      0x0000
                  |L1.60|
                          DCD      ||.bss||+0x20

                          AREA ||i.Key_Init||, CODE, READONLY, ALIGN=2

                  Key_Init PROC
;;;15       */
;;;16     void Key_Init(Key_InitTypeDef* Key_InitStruct)
000000  b57f              PUSH     {r0-r6,lr}
;;;17     {
;;;18     	if(Key_Handler.keyCount >= KEY_ID_MAX) return;
000002  4d1f              LDR      r5,|L2.128|
000004  7e29              LDRB     r1,[r5,#0x18]  ; Key_Handler
000006  2904              CMP      r1,#4
000008  d232              BCS      |L2.112|
;;;19     	
;;;20     	uint8_t idx = Key_Handler.keyCount;
;;;21     	
;;;22         /* 保存配置 */
;;;23         Key_Handler.config[idx].GPIOx = Key_InitStruct->GPIOx;
00000a  220c              MOVS     r2,#0xc
00000c  4351              MULS     r1,r2,r1
00000e  462a              MOV      r2,r5
000010  3a20              SUBS     r2,r2,#0x20
000012  6803              LDR      r3,[r0,#0]
000014  5053              STR      r3,[r2,r1]
;;;24         Key_Handler.config[idx].GPIO_Pin = Key_InitStruct->GPIO_Pin;
000016  8883              LDRH     r3,[r0,#4]
000018  188c              ADDS     r4,r1,r2
00001a  80a3              STRH     r3,[r4,#4]
;;;25         Key_Handler.config[idx].INT_Channel = Key_InitStruct->INT_Channel;
00001c  88c6              LDRH     r6,[r0,#6]
00001e  80e6              STRH     r6,[r4,#6]
;;;26         Key_Handler.config[idx].INT_Port = Key_InitStruct->INT_Port;
000020  7a06              LDRB     r6,[r0,#8]
000022  7226              STRB     r6,[r4,#8]
;;;27         Key_Handler.config[idx].ActiveLevel = Key_InitStruct->ActiveLevel;
000024  7a46              LDRB     r6,[r0,#9]
000026  7266              STRB     r6,[r4,#9]
;;;28         Key_Handler.config[idx].KeyID = Key_InitStruct->KeyID;
000028  7a80              LDRB     r0,[r0,#0xa]
00002a  72a0              STRB     r0,[r4,#0xa]
;;;29         
;;;30         /* GPIO初始化 - 上拉输入模式 */
;;;31         GPIO_InitTypeDef GPIO_InitStructure;
;;;32         GPIO_InitStructure.GPIO_Pin = Key_Handler.config[idx].GPIO_Pin;
00002c  4668              MOV      r0,sp
00002e  8103              STRH     r3,[r0,#8]
;;;33         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_PU;  // 上拉输入
000030  2601              MOVS     r6,#1
000032  8146              STRH     r6,[r0,#0xa]
;;;34         GPIO_InitStructure.GPIO_DriveLevel = GPIO_DriveLevel_0;
000034  2300              MOVS     r3,#0
000036  8183              STRH     r3,[r0,#0xc]
;;;35         GPIO_Init(Key_Handler.config[idx].GPIOx, &GPIO_InitStructure);
000038  5850              LDR      r0,[r2,r1]
00003a  a902              ADD      r1,sp,#8
00003c  f7fffffe          BL       GPIO_Init
;;;36         
;;;37         /* 外部中断初始化 */
;;;38         INT_InitTypeDef INT_InitStructure;
;;;39         INT_InitStructure.INT_Channel = Key_Handler.config[idx].INT_Channel;
000040  88e1              LDRH     r1,[r4,#6]
000042  4668              MOV      r0,sp
000044  8001              STRH     r1,[r0,#0]
;;;40         INT_InitStructure.INT_INTSEL = Key_Handler.config[idx].INT_Port;
000046  7a21              LDRB     r1,[r4,#8]
000048  8081              STRH     r1,[r0,#4]
;;;41         
;;;42         /* 根据有效电平配置触发方式 */
;;;43         if(Key_Handler.config[idx].ActiveLevel == KEY_PRESSED) {
00004a  7a60              LDRB     r0,[r4,#9]
00004c  2801              CMP      r0,#1
00004e  d010              BEQ      |L2.114|
;;;44             // 按下为低电平：下降沿触发
;;;45             INT_InitStructure.INT_Trigger = INT_Trigger_Falling;
;;;46         } else {
;;;47             // 按下为高电平：上升沿触发
;;;48             INT_InitStructure.INT_Trigger = INT_Trigger_Rising;
000050  4668              MOV      r0,sp
000052  8046              STRH     r6,[r0,#2]
                  |L2.84|
;;;49         }
;;;50         
;;;51         INT_Init(&INT_InitStructure);
000054  4668              MOV      r0,sp
000056  f7fffffe          BL       INT_Init
;;;52         
;;;53         /* 使能外部中断 */
;;;54         INT_ITConfig(Key_Handler.config[idx].INT_Channel, 
00005a  7a60              LDRB     r0,[r4,#9]
00005c  2801              CMP      r0,#1
00005e  d00c              BEQ      |L2.122|
;;;55                      (Key_Handler.config[idx].ActiveLevel == KEY_PRESSED) ? INT_IT_Falling : INT_IT_Rising, 
000060  2101              MOVS     r1,#1
                  |L2.98|
000062  88e0              LDRH     r0,[r4,#6]
000064  2201              MOVS     r2,#1
000066  f7fffffe          BL       INT_ITConfig
;;;56                      ENABLE);
;;;57         Key_Handler.keyCount++;
00006a  7e28              LDRB     r0,[r5,#0x18]  ; Key_Handler
00006c  1c40              ADDS     r0,r0,#1
00006e  7628              STRB     r0,[r5,#0x18]
                  |L2.112|
;;;58     }
000070  bd7f              POP      {r0-r6,pc}
                  |L2.114|
000072  2002              MOVS     r0,#2                 ;45
000074  4669              MOV      r1,sp                 ;45
000076  8048              STRH     r0,[r1,#2]            ;45
000078  e7ec              B        |L2.84|
                  |L2.122|
00007a  2102              MOVS     r1,#2                 ;55
00007c  e7f1              B        |L2.98|
;;;59     
                          ENDP

00007e  0000              DCW      0x0000
                  |L2.128|
                          DCD      ||.bss||+0x20

                          AREA ||i.Key_Read||, CODE, READONLY, ALIGN=2

                  Key_Read PROC
;;;62       */
;;;63     Key_State Key_Read(Key_ID keyId)
000000  b510              PUSH     {r4,lr}
;;;64     {
;;;65     	if(keyId >= Key_Handler.keyCount) return KEY_RELEASED;  // 边界检查
000002  490e              LDR      r1,|L3.60|
000004  7e09              LDRB     r1,[r1,#0x18]  ; Key_Handler
000006  4281              CMP      r1,r0
000008  d916              BLS      |L3.56|
;;;66         BitAction pin_state = GPIO_ReadDataBit(Key_Handler.config[keyId].GPIOx, Key_Handler.config[keyId].GPIO_Pin);
00000a  4a0c              LDR      r2,|L3.60|
00000c  210c              MOVS     r1,#0xc
00000e  4348              MULS     r0,r1,r0
000010  3a20              SUBS     r2,r2,#0x20
000012  1884              ADDS     r4,r0,r2
000014  88a1              LDRH     r1,[r4,#4]
000016  5810              LDR      r0,[r2,r0]
000018  f7fffffe          BL       GPIO_ReadDataBit
;;;67         
;;;68         if((pin_state == SET && Key_Handler.config[keyId].ActiveLevel == KEY_PRESSED) ||
00001c  2801              CMP      r0,#1
00001e  d002              BEQ      |L3.38|
;;;69            (pin_state == RESET && Key_Handler.config[keyId].ActiveLevel == KEY_RELEASED)) {
000020  2800              CMP      r0,#0
000022  d004              BEQ      |L3.46|
000024  e006              B        |L3.52|
                  |L3.38|
000026  7a60              LDRB     r0,[r4,#9]            ;68
000028  2801              CMP      r0,#1                 ;68
00002a  d005              BEQ      |L3.56|
00002c  e002              B        |L3.52|
                  |L3.46|
00002e  7a60              LDRB     r0,[r4,#9]
000030  2800              CMP      r0,#0
000032  d001              BEQ      |L3.56|
                  |L3.52|
;;;70             return KEY_RELEASED;
;;;71         } else {
;;;72             return KEY_PRESSED;
000034  2001              MOVS     r0,#1
;;;73         }
;;;74     }
000036  bd10              POP      {r4,pc}
                  |L3.56|
000038  2000              MOVS     r0,#0                 ;70
00003a  bd10              POP      {r4,pc}
;;;75     
                          ENDP

                  |L3.60|
                          DCD      ||.bss||+0x20

                          AREA ||i.Key_SetPressCallback||, CODE, READONLY, ALIGN=2

                  Key_SetPressCallback PROC
;;;78       */
;;;79     void Key_SetPressCallback(Key_Callback callback)
000000  4901              LDR      r1,|L4.8|
;;;80     {
;;;81         Key_Handler.PressCallback = callback;
000002  6308              STR      r0,[r1,#0x30]  ; Key_Handler
;;;82     }
000004  4770              BX       lr
;;;83     
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      ||.bss||

                          AREA ||i.Key_SetReleaseCallback||, CODE, READONLY, ALIGN=2

                  Key_SetReleaseCallback PROC
;;;86       */
;;;87     void Key_SetReleaseCallback(Key_Callback callback)
000000  4901              LDR      r1,|L5.8|
;;;88     {
;;;89         Key_Handler.ReleaseCallback = callback;
000002  6348              STR      r0,[r1,#0x34]  ; Key_Handler
;;;90     }
000004  4770              BX       lr
;;;91     
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Key_Handler
                          %        60

;*** Start embedded assembler ***

#line 1 "..\\HardDrive\\key.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_key_c_Key_Init____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___5_key_c_Key_Init____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_key_c_Key_Init____REVSH|
#line 478
|__asm___5_key_c_Key_Init____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
