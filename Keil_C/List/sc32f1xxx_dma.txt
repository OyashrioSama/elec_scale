; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: armcc [4d365d]
; commandline armcc [--c99 --list --split_sections --debug -c --asm --interleave -o..\Output\sc32f1xxx_dma.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\Output\sc32f1xxx_dma.d --cpu=Cortex-M0+ --apcs=interwork --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -I..\HardDrive -I..\Application -D__UVISION_VERSION=536 -DSC32f12xx --omf_browse=..\Output\sc32f1xxx_dma.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_dma.c]
                          THUMB

                          AREA ||i.DMA_CHRQCmd||, CODE, READONLY, ALIGN=1

                  DMA_CHRQCmd PROC
;;;222      */
;;;223    void DMA_CHRQCmd ( DMA_TypeDef* DMAx, FunctionalState NewState )
000000  2201              MOVS     r2,#1
;;;224    {
;;;225        /* Check the parameters */
;;;226        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;227        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;228    
;;;229        if ( NewState != DISABLE )
;;;230        {
;;;231            /* Enable the selected DMAy Streamx by setting CHRQ bit */
;;;232            DMAx->DMA_CFG |= ( uint32_t ) DMA_CFG_CHRQ;
000002  05d2              LSLS     r2,r2,#23
000004  2900              CMP      r1,#0                 ;229
;;;233        }
;;;234        else
;;;235        {
;;;236            /* Enable the selected DMAy Streamx by clearing CHRQ bit */
;;;237            DMAx->DMA_CFG &= ( uint32_t ) ~DMA_CFG_CHRQ;
000006  6881              LDR      r1,[r0,#8]
000008  d001              BEQ      |L1.14|
00000a  4311              ORRS     r1,r1,r2              ;232
00000c  e000              B        |L1.16|
                  |L1.14|
00000e  4391              BICS     r1,r1,r2
                  |L1.16|
000010  6081              STR      r1,[r0,#8]            ;232
;;;238        }
;;;239    }
000012  4770              BX       lr
;;;240    
                          ENDP


                          AREA ||i.DMA_ChannelReset||, CODE, READONLY, ALIGN=1

                  DMA_ChannelReset PROC
;;;251      */
;;;252    void DMA_ChannelReset ( DMA_TypeDef* DMAx )
000000  6881              LDR      r1,[r0,#8]
;;;253    {
;;;254        /* Check the parameters */
;;;255        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;256    
;;;257        DMAx->DMA_CFG |= ( uint32_t ) DMA_CFG_CHRST;
000002  2240              MOVS     r2,#0x40
000004  4311              ORRS     r1,r1,r2
000006  6081              STR      r1,[r0,#8]
;;;258    }
000008  4770              BX       lr
;;;259    
                          ENDP


                          AREA ||i.DMA_ClearFlag||, CODE, READONLY, ALIGN=1

                  DMA_ClearFlag PROC
;;;523      */
;;;524    void DMA_ClearFlag ( DMA_TypeDef* DMAx, uint32_t DMA_FLAG )
000000  6101              STR      r1,[r0,#0x10]
;;;525    {
;;;526        /* Check the parameters */
;;;527        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;528        assert_param ( IS_GET_DMA_FLAG ( DMA_FLAG ) );
;;;529    
;;;530        /* Set DMAy STS register clear flag bits */
;;;531        DMAx->DMA_STS = ( uint32_t ) ( DMA_FLAG );
;;;532    }
000002  4770              BX       lr
;;;533    
                          ENDP


                          AREA ||i.DMA_Cmd||, CODE, READONLY, ALIGN=1

                  DMA_Cmd PROC
;;;158      */
;;;159    void DMA_Cmd ( DMA_TypeDef* DMAx, FunctionalState NewState )
000000  2280              MOVS     r2,#0x80
;;;160    {
;;;161        /* Check the parameters */
;;;162        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;163        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;164    
;;;165        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
;;;166        {
;;;167            /* Enable the selected DMAy Streamx by setting EN bit */
;;;168            DMAx->DMA_CFG |= ( uint32_t ) DMA_CFG_CHEN;
;;;169        }
;;;170        else
;;;171        {
;;;172            /* Disable the selected DMAy Streamx by clearing EN bit */
;;;173            DMAx->DMA_CFG &= ~ ( uint32_t ) DMA_CFG_CHEN;
000004  6881              LDR      r1,[r0,#8]
000006  d001              BEQ      |L4.12|
000008  4311              ORRS     r1,r1,r2              ;168
00000a  e000              B        |L4.14|
                  |L4.12|
00000c  4391              BICS     r1,r1,r2
                  |L4.14|
00000e  6081              STR      r1,[r0,#8]            ;168
;;;174        }
;;;175    }
000010  4770              BX       lr
;;;176    
                          ENDP


                          AREA ||i.DMA_DMACmd||, CODE, READONLY, ALIGN=1

                  DMA_DMACmd PROC
;;;549      */
;;;550    void DMA_DMACmd ( DMA_TypeDef* DMAx, uint32_t DMA_DMARequest, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;551    {
;;;552        /* Check the parameters */
;;;553        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;554        assert_param ( IS_DMA_DMAREQ ( DMA_DMARequest ) );
;;;555    
;;;556        /* Config DMA Request */
;;;557        if ( NewState != DISABLE )
;;;558        {
;;;559            /* Enable the selected DMA Request */
;;;560            DMAx->DMA_CFG |= ( uint32_t ) ( DMA_DMARequest );
;;;561        }
;;;562        else
;;;563        {
;;;564            /* Disable the selected DMA Request */
;;;565            DMAx->DMA_CFG &= ( uint32_t ) ~ ( DMA_DMARequest );
000002  6882              LDR      r2,[r0,#8]
000004  d001              BEQ      |L5.10|
000006  430a              ORRS     r2,r2,r1              ;560
000008  e000              B        |L5.12|
                  |L5.10|
00000a  438a              BICS     r2,r2,r1
                  |L5.12|
00000c  6082              STR      r2,[r0,#8]            ;560
;;;566        }
;;;567    }
00000e  4770              BX       lr
;;;568    
                          ENDP


                          AREA ||i.DMA_DeInit||, CODE, READONLY, ALIGN=1

                  DMA_DeInit PROC
;;;55      */
;;;56     void DMA_DeInit ( DMA_TypeDef* DMAx )
000000  b510              PUSH     {r4,lr}
;;;57     {
;;;58         /* Check the parameters */
;;;59         assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;60     
;;;61         if ( DMAx != 0x00 )
000002  2800              CMP      r0,#0
000004  d007              BEQ      |L6.22|
;;;62         {
;;;63             /* Enable DMA reset state */
;;;64             RCC_AHBPeriphResetCmd ( RCC_AHBPeriph_DMA, ENABLE );
000006  2101              MOVS     r1,#1
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       RCC_AHBPeriphResetCmd
;;;65             /* Release DMA from reset state */
;;;66             RCC_AHBPeriphResetCmd ( RCC_AHBPeriph_DMA, DISABLE );
00000e  2100              MOVS     r1,#0
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       RCC_AHBPeriphResetCmd
                  |L6.22|
;;;67         }
;;;68     }
000016  bd10              POP      {r4,pc}
;;;69     
                          ENDP


                          AREA ||i.DMA_GetCurrDataCounter||, CODE, READONLY, ALIGN=1

                  DMA_GetCurrDataCounter PROC
;;;351      */
;;;352    uint32_t DMA_GetCurrDataCounter ( DMA_TypeDef* DMAx )
000000  68c0              LDR      r0,[r0,#0xc]
;;;353    {
;;;354        /* Check the parameters */
;;;355        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;356    
;;;357        /* Return The number of DMA transfers */
;;;358        return ( ( uint32_t ) ( DMAx->DMA_CNT ) );
;;;359    }
000002  4770              BX       lr
;;;360    
                          ENDP


                          AREA ||i.DMA_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  DMA_GetFlagStatus PROC
;;;482      */
;;;483    FlagStatus DMA_GetFlagStatus ( DMA_TypeDef* DMAx, DMA_Flag_TypeDef DMA_FLAG )
000000  4602              MOV      r2,r0
;;;484    {
;;;485        FlagStatus bitstatus = RESET;
;;;486    
;;;487        /* Check the parameters */
;;;488        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;489        assert_param ( IS_GET_DMA_FLAG ( DMA_FLAG ) );
;;;490    
;;;491    
;;;492        /* Check the status of the specified DMA flag */
;;;493        if ( ( DMAx->DMA_STS & DMA_FLAG ) != ( uint32_t ) RESET )
000002  6912              LDR      r2,[r2,#0x10]
000004  2000              MOVS     r0,#0                 ;485
000006  420a              TST      r2,r1
000008  d000              BEQ      |L8.12|
;;;494        {
;;;495            /* DMA_FLAG is set */
;;;496            bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L8.12|
;;;497        }
;;;498        else
;;;499        {
;;;500            /* DMA_FLAG is reset */
;;;501            bitstatus = RESET;
;;;502        }
;;;503    
;;;504        /* Return the DMA_FLAG status */
;;;505        return  bitstatus;
;;;506    }
00000c  4770              BX       lr
;;;507    
                          ENDP


                          AREA ||i.DMA_GetStatus||, CODE, READONLY, ALIGN=1

                  DMA_GetStatus PROC
;;;414      */
;;;415    DMA_State_TypeDef DMA_GetStatus ( DMA_TypeDef* DMAx )
000000  6900              LDR      r0,[r0,#0x10]
;;;416    {
;;;417        DMA_State_TypeDef Status;
;;;418    
;;;419        /* Check the parameters */
;;;420        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;421    
;;;422        Status = ( DMA_State_TypeDef ) ( DMAx->DMA_STS & DMA_STS_STATUS );
000002  21f0              MOVS     r1,#0xf0
000004  4008              ANDS     r0,r0,r1
;;;423        return Status;
;;;424    }
000006  4770              BX       lr
;;;425    
                          ENDP


                          AREA ||i.DMA_ITConfig||, CODE, READONLY, ALIGN=1

                  DMA_ITConfig PROC
;;;445      */
;;;446    void DMA_ITConfig ( DMA_TypeDef* DMAx, uint32_t DMA_IT, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;447    {
;;;448        /* Check the parameters */
;;;449        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;450        assert_param ( IS_DMA_IT ( DMA_IT ) );
;;;451        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;452    
;;;453        if ( NewState != DISABLE )
;;;454        {
;;;455            /* Enable the selected DMA transfer interrupts */
;;;456            DMAx->DMA_CFG |= ( uint32_t ) ( DMA_IT );
;;;457        }
;;;458        else
;;;459        {
;;;460            /* Disable the selected DMA transfer interrupts */
;;;461            DMAx->DMA_CFG &= ~ ( uint32_t ) ( DMA_IT );
000002  6882              LDR      r2,[r0,#8]
000004  d001              BEQ      |L10.10|
000006  430a              ORRS     r2,r2,r1              ;456
000008  e000              B        |L10.12|
                  |L10.10|
00000a  438a              BICS     r2,r2,r1
                  |L10.12|
00000c  6082              STR      r2,[r0,#8]            ;456
;;;462        }
;;;463    }
00000e  4770              BX       lr
;;;464    
                          ENDP


                          AREA ||i.DMA_Init||, CODE, READONLY, ALIGN=2

                  DMA_Init PROC
;;;82      */
;;;83     void DMA_Init ( DMA_TypeDef* DMAx, DMA_InitTypeDef* DMA_InitStruct )
000000  b530              PUSH     {r4,r5,lr}
;;;84     {
;;;85         uint32_t tmpreg;
;;;86         /* Check the parameters */
;;;87         assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;88         assert_param ( IS_DMA_PROIORITY ( DMA_InitStruct->DMA_Priority ) );
;;;89         assert_param ( IS_DMA_CIRCULARMODE ( DMA_InitStruct->DMA_CircularMode ) );
;;;90         assert_param ( IS_DMA_DATASIZE ( DMA_InitStruct->DMA_DataSize ) );
;;;91         assert_param ( IS_DMA_TARGERT_MODE ( DMA_InitStruct->DMA_TargetMode ) );
;;;92         assert_param ( IS_DMA_SOURCE_MODE ( DMA_InitStruct->DMA_SourceMode ) );
;;;93         assert_param ( IS_DMA_BURST ( DMA_InitStruct->DMA_Burst ) );
;;;94     
;;;95         tmpreg = DMAx->DMA_CFG;
000002  6882              LDR      r2,[r0,#8]
;;;96     
;;;97         tmpreg &=
000004  4b0b              LDR      r3,|L11.52|
;;;98             ( uint32_t ) ~ ( DMA_CFG_PL | DMA_CFG_TXWIDTH | DMA_CFG_CIRC |
;;;99                              DMA_CFG_CHRST | DMA_CFG_CHEN | DMA_CFG_DAINC | DMA_CFG_SAINC |
;;;100                             DMA_CFG_BURSIZE | DMA_CFG_TPTYPE |
;;;101                             DMA_CFG_REQSRC );
;;;102        tmpreg |=
000006  884c              LDRH     r4,[r1,#2]
000008  401a              ANDS     r2,r2,r3              ;97
00000a  880b              LDRH     r3,[r1,#0]
00000c  88cd              LDRH     r5,[r1,#6]
00000e  4323              ORRS     r3,r3,r4
000010  888c              LDRH     r4,[r1,#4]
000012  432c              ORRS     r4,r4,r5
000014  4323              ORRS     r3,r3,r4
000016  890c              LDRH     r4,[r1,#8]
000018  4323              ORRS     r3,r3,r4
00001a  894c              LDRH     r4,[r1,#0xa]
00001c  4323              ORRS     r3,r3,r4
00001e  690c              LDR      r4,[r1,#0x10]
000020  4323              ORRS     r3,r3,r4
000022  4313              ORRS     r3,r3,r2
;;;103            ( uint32_t ) ( DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_CircularMode |
;;;104                           DMA_InitStruct->DMA_DataSize | DMA_InitStruct->DMA_TargetMode |
;;;105                           DMA_InitStruct->DMA_SourceMode | DMA_InitStruct->DMA_Burst |
;;;106                           DMA_InitStruct->DMA_Request );
;;;107    
;;;108        DMAx->DMA_CFG = tmpreg;
000024  6083              STR      r3,[r0,#8]
;;;109    
;;;110        DMAx->DMA_SADR = DMA_InitStruct->DMA_SrcAddress;
000026  694a              LDR      r2,[r1,#0x14]
000028  6002              STR      r2,[r0,#0]
;;;111        DMAx->DMA_DADR = DMA_InitStruct->DMA_DstAddress;
00002a  698a              LDR      r2,[r1,#0x18]
00002c  6042              STR      r2,[r0,#4]
;;;112        DMAx->DMA_CNT = DMA_InitStruct->DMA_BufferSize;
00002e  68c9              LDR      r1,[r1,#0xc]
000030  60c1              STR      r1,[r0,#0xc]
;;;113    }
000032  bd30              POP      {r4,r5,pc}
;;;114    
                          ENDP

                  |L11.52|
                          DCD      0xc0ff0020

                          AREA ||i.DMA_PauseCmd||, CODE, READONLY, ALIGN=1

                  DMA_PauseCmd PROC
;;;190      */
;;;191    void DMA_PauseCmd ( DMA_TypeDef* DMAx, FunctionalState NewState )
000000  2220              MOVS     r2,#0x20
;;;192    {
;;;193        /* Check the parameters */
;;;194        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;195        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;196    
;;;197        if ( NewState != DISABLE )
000002  2900              CMP      r1,#0
;;;198        {
;;;199            /* Enable the selected DMAy Streamx by setting PAUSE bit */
;;;200            DMAx->DMA_CFG |= ( uint32_t ) DMA_CFG_PAUSE;
;;;201        }
;;;202        else
;;;203        {
;;;204            /* Enable the selected DMAy Streamx by clearing EN bit */
;;;205            DMAx->DMA_CFG = ( uint32_t ) ( ( DMAx->DMA_CFG | DMA_CFG_CHEN ) & ( ~DMA_CFG_PAUSE ) );
000004  6881              LDR      r1,[r0,#8]
000006  d001              BEQ      |L12.12|
000008  4311              ORRS     r1,r1,r2              ;200
00000a  e002              B        |L12.18|
                  |L12.12|
00000c  2380              MOVS     r3,#0x80
00000e  4319              ORRS     r1,r1,r3
000010  4391              BICS     r1,r1,r2
                  |L12.18|
000012  6081              STR      r1,[r0,#8]            ;200
;;;206        }
;;;207    }
000014  4770              BX       lr
;;;208    
                          ENDP


                          AREA ||i.DMA_SetCurrDataCounter||, CODE, READONLY, ALIGN=1

                  DMA_SetCurrDataCounter PROC
;;;331      */
;;;332    void DMA_SetCurrDataCounter ( DMA_TypeDef* DMAx, uint32_t Counter )
000000  60c1              STR      r1,[r0,#0xc]
;;;333    {
;;;334        /* Check the parameters */
;;;335        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;336    
;;;337        /* Write the number of data units to be transferred */
;;;338        DMAx->DMA_CNT = ( uint32_t ) Counter;
;;;339    }
000002  4770              BX       lr
;;;340    
                          ENDP


                          AREA ||i.DMA_SetDstAddress||, CODE, READONLY, ALIGN=1

                  DMA_SetDstAddress PROC
;;;308      */
;;;309    void DMA_SetDstAddress ( DMA_TypeDef* DMAx, uint32_t DstAddress )
000000  6041              STR      r1,[r0,#4]
;;;310    {
;;;311        /* Check the parameters */
;;;312        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;313    
;;;314        /* Write the number of data units to be transferred */
;;;315        DMAx->DMA_DADR = ( uint32_t ) DstAddress;
;;;316    }
000002  4770              BX       lr
;;;317    
                          ENDP


                          AREA ||i.DMA_SetSrcAddress||, CODE, READONLY, ALIGN=1

                  DMA_SetSrcAddress PROC
;;;287      */
;;;288    void DMA_SetSrcAddress ( DMA_TypeDef* DMAx, uint32_t SrcAddress )
000000  6001              STR      r1,[r0,#0]
;;;289    {
;;;290        /* Check the parameters */
;;;291        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;292    
;;;293        /* Write the number of data units to be transferred */
;;;294        DMAx->DMA_SADR = ( uint32_t ) SrcAddress;
;;;295    }
000002  4770              BX       lr
;;;296    
                          ENDP


                          AREA ||i.DMA_SoftwareTrigger||, CODE, READONLY, ALIGN=1

                  DMA_SoftwareTrigger PROC
;;;371      */
;;;372    void DMA_SoftwareTrigger ( DMA_TypeDef* DMAx )
000000  21ff              MOVS     r1,#0xff
;;;373    {
;;;374        /* Check the parameters */
;;;375        assert_param ( IS_DMA_ALL_PERIPH ( DMAx ) );
;;;376    
;;;377        /* Set DMA STS SWREQ Bit */
;;;378        DMAx->DMA_STS = DMA_STS_SWREQ;
000002  3101              ADDS     r1,#1
000004  6101              STR      r1,[r0,#0x10]
;;;379    }
000006  4770              BX       lr
;;;380    /**
                          ENDP


                          AREA ||i.DMA_StructInit||, CODE, READONLY, ALIGN=1

                  DMA_StructInit PROC
;;;119      */
;;;120    void DMA_StructInit ( DMA_InitTypeDef* DMA_InitStruct )
000000  2100              MOVS     r1,#0
;;;121    {
;;;122        /* Initialize the DMA_Priority member */
;;;123        DMA_InitStruct->DMA_Priority = DMA_Priority_LOW;
000002  8001              STRH     r1,[r0,#0]
;;;124    
;;;125        /* Initialize the DMA_CircularMode member */
;;;126        DMA_InitStruct->DMA_CircularMode = DMA_CircularMode_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;127    
;;;128        /* Initialize the DMA_DataSize member */
;;;129        DMA_InitStruct->DMA_DataSize = DMA_DataSize_Byte;
000006  8081              STRH     r1,[r0,#4]
;;;130    
;;;131        /* Initialize the DMA_TargetMode member */
;;;132        DMA_InitStruct->DMA_TargetMode = DMA_TargetMode_FIXED;
000008  80c1              STRH     r1,[r0,#6]
;;;133    
;;;134        /* Initialize the DMA_SourceMode member */
;;;135        DMA_InitStruct->DMA_SourceMode = DMA_SourceMode_FIXED;
00000a  8101              STRH     r1,[r0,#8]
;;;136    
;;;137        /* Initialize the DMA_Burst member */
;;;138        DMA_InitStruct->DMA_Burst = DMA_Burst_Disable;
00000c  8141              STRH     r1,[r0,#0xa]
;;;139    
;;;140        /* Initialize the DMA_Request member */
;;;141        DMA_InitStruct->DMA_Request = DMA_Request_Null;
00000e  6101              STR      r1,[r0,#0x10]
;;;142    }
000010  4770              BX       lr
;;;143    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_dma.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_dma_c_e9b554c0____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_dma_c_e9b554c0____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_dma_c_e9b554c0____REVSH|
#line 478
|__asm___15_sc32f1xxx_dma_c_e9b554c0____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
