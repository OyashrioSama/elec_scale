; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: armcc [4d365d]
; commandline armcc [--c99 --list --split_sections --debug -c --asm --interleave -o..\Output\sc32f1xxx_iap.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\Output\sc32f1xxx_iap.d --cpu=Cortex-M0+ --apcs=interwork --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -D__UVISION_VERSION=536 -DSC32f12xx --omf_browse=..\Output\sc32f1xxx_iap.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_iap.c]
                          THUMB

                          AREA ||i.IAP_EEPROMEraseSector||, CODE, READONLY, ALIGN=2

                  IAP_EEPROMEraseSector PROC
;;;360      */
;;;361    void IAP_EEPROMEraseSector ( uint32_t IAP_Sector )
000000  2169              MOVS     r1,#0x69
;;;362    {
;;;363        uint32_t tmpreg;
;;;364        IAP->IAP_SNB = 0x69000000 | IAP_Sector;
000002  0609              LSLS     r1,r1,#24
000004  4308              ORRS     r0,r0,r1
000006  4908              LDR      r1,|L1.40|
000008  6048              STR      r0,[r1,#4]
;;;365        tmpreg = IAP->IAP_CON;
00000a  68c8              LDR      r0,[r1,#0xc]
;;;366        tmpreg &= (uint32_t)~(IAP_CON_ERASE | IAP_CON_CMD | IAP_CON_PRG);
00000c  2293              MOVS     r2,#0x93
00000e  4390              BICS     r0,r0,r2
;;;367        tmpreg |= (uint32_t)(IAP_CON_SERASE  );
000010  2220              MOVS     r2,#0x20
000012  4310              ORRS     r0,r0,r2
;;;368    		/* Check if software lock is open (IAP write operations are permitted) */
;;;369    		if(IapWriteFlag==IAP_ENABLE)
000014  4a05              LDR      r2,|L1.44|
000016  6852              LDR      r2,[r2,#4]  ; IapWriteFlag
000018  2a69              CMP      r2,#0x69
00001a  d104              BNE      |L1.38|
;;;370    		{
;;;371    				IAP->IAP_CON = tmpreg;
00001c  60c8              STR      r0,[r1,#0xc]
;;;372    				IAP->IAP_CON |= (0x02 << IAP_CON_CMD_Pos);
00001e  68c8              LDR      r0,[r1,#0xc]
000020  2202              MOVS     r2,#2
000022  4310              ORRS     r0,r0,r2
000024  60c8              STR      r0,[r1,#0xc]
                  |L1.38|
;;;373    		}
;;;374    }
000026  4770              BX       lr
;;;375    
                          ENDP

                  |L1.40|
                          DCD      0x400003c0
                  |L1.44|
                          DCD      ||.data||

                          AREA ||i.IAP_EraseSector||, CODE, READONLY, ALIGN=2

                  IAP_EraseSector PROC
;;;336      */
;;;337    void IAP_EraseSector ( uint32_t IAP_Sector )
000000  2113              MOVS     r1,#0x13
;;;338    {
;;;339        uint32_t tmpreg;
;;;340        IAP->IAP_SNB = 0x4C000000 | IAP_Sector;
000002  0689              LSLS     r1,r1,#26
000004  4308              ORRS     r0,r0,r1
000006  4908              LDR      r1,|L2.40|
000008  6048              STR      r0,[r1,#4]
;;;341        tmpreg = IAP->IAP_CON;
00000a  68c8              LDR      r0,[r1,#0xc]
;;;342        tmpreg &= ( uint32_t ) ~ ( IAP_CON_ERASE | IAP_CON_CMD | IAP_CON_PRG );
00000c  2293              MOVS     r2,#0x93
00000e  4390              BICS     r0,r0,r2
;;;343        tmpreg |= ( uint32_t ) ( IAP_CON_SERASE );
000010  2220              MOVS     r2,#0x20
000012  4310              ORRS     r0,r0,r2
;;;344    		/* Check if software lock is open (IAP write operations are permitted) */
;;;345    		if(IapWriteFlag==IAP_ENABLE)
000014  4a05              LDR      r2,|L2.44|
000016  6852              LDR      r2,[r2,#4]  ; IapWriteFlag
000018  2a69              CMP      r2,#0x69
00001a  d104              BNE      |L2.38|
;;;346    		{
;;;347    				IAP->IAP_CON = tmpreg;
00001c  60c8              STR      r0,[r1,#0xc]
;;;348    				IAP->IAP_CON |= ( 0x02 << IAP_CON_CMD_Pos );
00001e  68c8              LDR      r0,[r1,#0xc]
000020  2202              MOVS     r2,#2
000022  4310              ORRS     r0,r0,r2
000024  60c8              STR      r0,[r1,#0xc]
                  |L2.38|
;;;349    		}
;;;350    }
000026  4770              BX       lr
;;;351    
                          ENDP

                  |L2.40|
                          DCD      0x400003c0
                  |L2.44|
                          DCD      ||.data||

                          AREA ||i.IAP_Lock||, CODE, READONLY, ALIGN=2

                  IAP_Lock PROC
;;;294      */
;;;295    void IAP_Lock ( void )
000000  2001              MOVS     r0,#1
;;;296    {
;;;297        /* Set the LOCK Bit to lock the FLASH Registers access */
;;;298        IAP->IAP_CON = ( uint32_t ) IAP_CON_LOCK;
000002  4907              LDR      r1,|L3.32|
000004  07c0              LSLS     r0,r0,#31
000006  60c8              STR      r0,[r1,#0xc]
000008  2000              MOVS     r0,#0
00000a  4a06              LDR      r2,|L3.36|
00000c  4601              MOV      r1,r0
                  |L3.14|
00000e  5411              STRB     r1,[r2,r0]
000010  1c40              ADDS     r0,r0,#1
000012  b280              UXTH     r0,r0
000014  28b4              CMP      r0,#0xb4
000016  d3fa              BCC      |L3.14|
000018  4904              LDR      r1,|L3.44|
00001a  4803              LDR      r0,|L3.40|
00001c  6008              STR      r0,[r1,#0]  ; pWriteIapFun
;;;299    	
;;;300    		DeInitFlashToRam();
;;;301    }
00001e  4770              BX       lr
;;;302    
                          ENDP

                  |L3.32|
                          DCD      0x400003c0
                  |L3.36|
                          DCD      ||.bss||
                  |L3.40|
                          DCD      IAP_NOP
                  |L3.44|
                          DCD      ||.data||

                          AREA ||i.IAP_NOP||, CODE, READONLY, ALIGN=1

                  IAP_NOP PROC
;;;87      */
;;;88     static boolType IAP_NOP(void)
000000  bf00              NOP      
;;;89     {
;;;90     		__NOP();
;;;91     		return FALSE;
000002  2000              MOVS     r0,#0
;;;92     }
000004  4770              BX       lr
;;;93     
                          ENDP


                          AREA ||i.IAP_ProgramArray_InRam||, CODE, READONLY, ALIGN=2

                  IAP_ProgramArray_InRam PROC
;;;180     */  
;;;181    static uint16_t IAP_ProgramArray_InRam( uint32_t Address, uint8_t* ByteArray, uint16_t ArraySize,IAPWRITE_ALIGNTYPE Type )
000000  b5f0              PUSH     {r4-r7,lr}
;;;182    {
;;;183    		uint16_t tmpCnt = 0;
;;;184    		/* Disable non-maskable interrupts */
;;;185    		uint32_t	Temp=RCC->NMI_CFG;
000002  4d27              LDR      r5,|L5.160|
000004  469c              MOV      r12,r3                ;182
000006  6aeb              LDR      r3,[r5,#0x2c]
000008  2400              MOVS     r4,#0                 ;183
;;;186    		Temp =(Temp&0x0000FFFF)|0xA05F0000;
00000a  4e26              LDR      r6,|L5.164|
00000c  b29b              UXTH     r3,r3
00000e  199f              ADDS     r7,r3,r6
;;;187    		RCC->NMI_CFG =Temp&0xFFFF0000;
000010  0c3b              LSRS     r3,r7,#16
000012  041b              LSLS     r3,r3,#16
000014  62eb              STR      r3,[r5,#0x2c]
;;;188    		/* Disable interrupt requests (IRQ) */
;;;189    		__disable_irq();
000016  b672              CPSID    i
;;;190    	  
;;;191    		/* Enable writing if the IAP software lock is open */
;;;192        /* IAP_WriteCmd(ENABLE); */
;;;193    		if(IapWriteFlag==IAP_ENABLE)
000018  4b23              LDR      r3,|L5.168|
00001a  685b              LDR      r3,[r3,#4]  ; IapWriteFlag
00001c  2b69              CMP      r3,#0x69
00001e  d135              BNE      |L5.140|
;;;194    		{
;;;195    				IAP->IAP_CON |= ( uint32_t ) IAP_CON_PRG;
000020  4e22              LDR      r6,|L5.172|
000022  68f3              LDR      r3,[r6,#0xc]
000024  2510              MOVS     r5,#0x10
000026  432b              ORRS     r3,r3,r5
000028  60f3              STR      r3,[r6,#0xc]
                  |L5.42|
;;;196    		}
;;;197    		if(IapWriteFlag==IAP_ENABLE)
;;;198    		{
;;;199    				do
;;;200    				{			
;;;201    						switch(Type)
00002a  4663              MOV      r3,r12
00002c  2b00              CMP      r3,#0
00002e  d004              BEQ      |L5.58|
000030  2b01              CMP      r3,#1
000032  d00c              BEQ      |L5.78|
000034  2b02              CMP      r3,#2
000036  d125              BNE      |L5.132|
000038  e017              B        |L5.106|
                  |L5.58|
;;;202    						{
;;;203    								/* Program byte (8-bit) Array at a specified address */
;;;204    								case IAP_BYTE:
;;;205    								{
;;;206    										* ( __IO uint8_t* ) Address = ByteArray[tmpCnt];
00003a  5d0b              LDRB     r3,[r1,r4]
00003c  7003              STRB     r3,[r0,#0]
;;;207    										* ( __IO uint8_t* ) Address = ByteArray[tmpCnt];
00003e  5d0b              LDRB     r3,[r1,r4]
000040  7003              STRB     r3,[r0,#0]
;;;208    										if ( ByteArray[tmpCnt] != * ( __IO uint8_t * ) Address )
000042  5d0b              LDRB     r3,[r1,r4]
000044  7805              LDRB     r5,[r0,#0]
000046  42ab              CMP      r3,r5
000048  d11c              BNE      |L5.132|
00004a  1c40              ADDS     r0,r0,#1
;;;209    										{
;;;210    												break;
;;;211    										}
;;;212    										Address = Address + 1;
;;;213    										break;
00004c  e01a              B        |L5.132|
                  |L5.78|
;;;214    								}
;;;215    								/* Program halfword (16-bit) Array at a specified address */
;;;216    								case IAP_HALFWORD:
;;;217    								{
;;;218    										uint16_t* ByteArray16=(uint16_t*)ByteArray;
00004e  460e              MOV      r6,r1
;;;219    										if ( ( Address & 0x01 ) == 0 )
000050  07c3              LSLS     r3,r0,#31
000052  d117              BNE      |L5.132|
;;;220    										{
;;;221    												* ( __IO uint16_t* ) Address = ByteArray16[tmpCnt];
000054  0065              LSLS     r5,r4,#1
000056  5b73              LDRH     r3,[r6,r5]
000058  8003              STRH     r3,[r0,#0]
;;;222    												* ( __IO uint16_t* ) Address = ByteArray16[tmpCnt];
00005a  5b73              LDRH     r3,[r6,r5]
00005c  8003              STRH     r3,[r0,#0]
;;;223    												if ( ByteArray16[tmpCnt] != * ( __IO uint16_t * ) Address )
00005e  5b4b              LDRH     r3,[r1,r5]
000060  8805              LDRH     r5,[r0,#0]
000062  42ab              CMP      r3,r5
000064  d10e              BNE      |L5.132|
000066  1c80              ADDS     r0,r0,#2
;;;224    												{
;;;225    														break;
;;;226    												}
;;;227    												Address = Address + 2;
000068  e00c              B        |L5.132|
                  |L5.106|
;;;228    										}
;;;229    										break;
;;;230    								}
;;;231    								/* Program word (32-bit) Array at a specified address */
;;;232    								case IAP_WORD:
;;;233    								{
;;;234    										uint32_t* ByteArray32=(uint32_t*)ByteArray;;
00006a  460e              MOV      r6,r1
;;;235    										if ( ( Address & 0x03 ) == 0 )
00006c  0783              LSLS     r3,r0,#30
00006e  d109              BNE      |L5.132|
;;;236    										{
;;;237    												* ( __IO uint32_t* ) Address = (uint32_t)ByteArray32[tmpCnt];
000070  00a5              LSLS     r5,r4,#2
000072  5973              LDR      r3,[r6,r5]
000074  6003              STR      r3,[r0,#0]
;;;238    												* ( __IO uint32_t* ) Address = (uint32_t)ByteArray32[tmpCnt];							
000076  5973              LDR      r3,[r6,r5]
000078  6003              STR      r3,[r0,#0]
;;;239    												if ( ByteArray32[tmpCnt] != * ( __IO uint32_t * ) Address )
00007a  594b              LDR      r3,[r1,r5]
00007c  6805              LDR      r5,[r0,#0]
00007e  42ab              CMP      r3,r5
000080  d100              BNE      |L5.132|
000082  1d00              ADDS     r0,r0,#4
                  |L5.132|
000084  1c64              ADDS     r4,r4,#1
;;;240    												{
;;;241    														break;			
;;;242    												}									
;;;243    												Address = Address + 4;
;;;244    										}	
;;;245    										break;					
;;;246    								}
;;;247    						}
;;;248    				}while ( ++tmpCnt < ArraySize );
000086  b2a4              UXTH     r4,r4
000088  4294              CMP      r4,r2
00008a  d3ce              BCC      |L5.42|
                  |L5.140|
;;;249    		}
;;;250    		/* IAP_WriteCmd(DISABLE); */
;;;251        IAP->IAP_CON &= ( uint32_t ) ~IAP_CON_PRG;		
00008c  4807              LDR      r0,|L5.172|
00008e  68c1              LDR      r1,[r0,#0xc]
000090  2210              MOVS     r2,#0x10
000092  4391              BICS     r1,r1,r2
000094  60c1              STR      r1,[r0,#0xc]
;;;252    		/* Enable interrupt requests (IRQ) */
;;;253        __enable_irq();
000096  b662              CPSIE    i
;;;254    		/* Restore the previous non-maskable interrupt (NMI) settings */
;;;255    		RCC->NMI_CFG =Temp;
000098  4801              LDR      r0,|L5.160|
00009a  62c7              STR      r7,[r0,#0x2c]
;;;256    		return  tmpCnt;
00009c  4620              MOV      r0,r4
;;;257    }
00009e  bdf0              POP      {r4-r7,pc}
;;;258    
                          ENDP

                  |L5.160|
                          DCD      0x40003000
                  |L5.164|
                          DCD      0xa05f0000
                  |L5.168|
                          DCD      ||.data||
                  |L5.172|
                          DCD      0x400003c0

                          AREA ||i.IAP_ProgramByte||, CODE, READONLY, ALIGN=2

                  IAP_ProgramByte PROC
;;;550      */
;;;551    boolType IAP_ProgramByte ( uint32_t Address, uint8_t Data )
000000  460b              MOV      r3,r1
;;;552    {
000002  4601              MOV      r1,r0
000004  b430              PUSH     {r4,r5}
;;;553        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;554    
;;;555        uint32_t Addr_Temp = Address & 0xFFFFFFFC;
000006  0880              LSRS     r0,r0,#2
000008  0080              LSLS     r0,r0,#2
;;;556        /*Read in the data for the aligned address*/
;;;557        uint32_t Data_Temp = * ( __IO uint32_t* ) Addr_Temp;
00000a  6802              LDR      r2,[r0,#0]
;;;558        /*Inserts the data to be written*/
;;;559        switch ( Address & 0x00000003 )
00000c  0789              LSLS     r1,r1,#30
00000e  0f89              LSRS     r1,r1,#30
000010  d005              BEQ      |L6.30|
000012  2901              CMP      r1,#1
000014  d006              BEQ      |L6.36|
000016  2902              CMP      r1,#2
000018  d006              BEQ      |L6.40|
;;;560        {
;;;561    				case 0:
;;;562    				{
;;;563    						Data_Temp |= ( uint32_t ) Data;
;;;564    						break;
;;;565    				}
;;;566    				case 1:
;;;567    				{
;;;568    						Data_Temp |= ( uint32_t ) ( Data << 8 );
;;;569    						break;
;;;570    				}
;;;571    				case 2:
;;;572    				{
;;;573    						Data_Temp |= ( uint32_t ) ( Data << 16 );
;;;574    						break;
;;;575    				}
;;;576    				default:
;;;577    				{
;;;578    						Data_Temp |= ( uint32_t ) ( Data << 24 );
00001a  0619              LSLS     r1,r3,#24
;;;579    						break;
00001c  e005              B        |L6.42|
                  |L6.30|
00001e  4611              MOV      r1,r2
000020  4319              ORRS     r1,r1,r3              ;563
000022  e003              B        |L6.44|
                  |L6.36|
000024  0219              LSLS     r1,r3,#8              ;568
000026  e000              B        |L6.42|
                  |L6.40|
000028  0419              LSLS     r1,r3,#16             ;573
                  |L6.42|
00002a  4311              ORRS     r1,r1,r2              ;568
                  |L6.44|
;;;580    				}
;;;581        }
;;;582        /* Check if the system clock source is HIRC, if using HIRC as system clock, 
;;;583    	     directly write data to FLASH memory at the specified address */
;;;584    		if(((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSW)==RESET)\
00002c  4a0e              LDR      r2,|L6.104|
00002e  6953              LDR      r3,[r2,#0x14]
000030  061c              LSLS     r4,r3,#24
;;;585    			 ||(((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSW)!=RESET)&&((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSEL)==(0x2UL << RCC_CFG0_SYSCLKSEL_Pos))))
;;;586    		{
;;;587    				/*Write incoming data*/
;;;588    				/* Check if software lock is open (IAP write operations are permitted) */
;;;589    				if(IapWriteFlag==IAP_ENABLE)
000032  4b0e              LDR      r3,|L6.108|
000034  d50b              BPL      |L6.78|
000036  6954              LDR      r4,[r2,#0x14]         ;585
000038  0624              LSLS     r4,r4,#24             ;585
00003a  d504              BPL      |L6.70|
00003c  6952              LDR      r2,[r2,#0x14]         ;585
00003e  0592              LSLS     r2,r2,#22             ;585
000040  0f92              LSRS     r2,r2,#30             ;585
000042  2a02              CMP      r2,#2                 ;585
000044  d003              BEQ      |L6.78|
                  |L6.70|
;;;590    				{
;;;591    						* ( __IO uint32_t* ) Addr_Temp = Data_Temp;
;;;592    				}
;;;593    				/* Verify the data was written correctly by reading it back */
;;;594    				if ( Data_Temp == * ( __IO uint32_t * ) Addr_Temp )
;;;595    						return TRUE;
;;;596    				else
;;;597    						return FALSE;
;;;598    		}
;;;599    		/* If not using HIRC as system clock, we need to jump to the function pointer pWriteIapFun
;;;600           which points to the IAP write function that was previously copied to RAM */
;;;601    		else
;;;602    		{
;;;603    				boolType Flag;
;;;604    			  /* Execute the IAP write function from RAM via the function pointer */
;;;605    				Flag=(*pWriteIapFun)(Addr_Temp,Data_Temp,IAP_WORD);
000046  681b              LDR      r3,[r3,#0]  ; pWriteIapFun
000048  bc30              POP      {r4,r5}
00004a  2202              MOVS     r2,#2
00004c  4718              BX       r3
                  |L6.78|
00004e  685a              LDR      r2,[r3,#4]            ;589  ; IapWriteFlag
000050  2a69              CMP      r2,#0x69              ;589
000052  d100              BNE      |L6.86|
000054  6001              STR      r1,[r0,#0]            ;591
                  |L6.86|
000056  6800              LDR      r0,[r0,#0]            ;594
000058  4288              CMP      r0,r1                 ;594
00005a  d102              BNE      |L6.98|
00005c  2001              MOVS     r0,#1                 ;595
                  |L6.94|
;;;606    			  /* Return the result from the RAM-executed function */
;;;607    				return Flag;
;;;608    		}
;;;609    
;;;610    }
00005e  bc30              POP      {r4,r5}
000060  4770              BX       lr
                  |L6.98|
000062  2000              MOVS     r0,#0                 ;597
000064  e7fb              B        |L6.94|
;;;611    /**
                          ENDP

000066  0000              DCW      0x0000
                  |L6.104|
                          DCD      0x40003000
                  |L6.108|
                          DCD      ||.data||

                          AREA ||i.IAP_ProgramHalfWord||, CODE, READONLY, ALIGN=2

                  IAP_ProgramHalfWord PROC
;;;619      */
;;;620    boolType IAP_ProgramHalfWord ( uint32_t Address, uint16_t Data )
000000  4602              MOV      r2,r0
;;;621    {
000002  b430              PUSH     {r4,r5}
;;;622        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;623    
;;;624        uint32_t Addr_Temp = Address & 0xFFFFFFFC;
000004  0880              LSRS     r0,r0,#2
000006  460b              MOV      r3,r1                 ;621
000008  0080              LSLS     r0,r0,#2
;;;625        /*Read in the data for the aligned address*/
;;;626        uint32_t Data_Temp = * ( __IO uint32_t* ) Addr_Temp;
00000a  6801              LDR      r1,[r0,#0]
;;;627        /*Inserts the data to be written*/
;;;628        switch ( Address & 0x00000003 )
00000c  0792              LSLS     r2,r2,#30
00000e  0f92              LSRS     r2,r2,#30
000010  d006              BEQ      |L7.32|
000012  2a01              CMP      r2,#1
000014  d023              BEQ      |L7.94|
000016  2a02              CMP      r2,#2
000018  d004              BEQ      |L7.36|
00001a  2a03              CMP      r2,#3
00001c  d104              BNE      |L7.40|
00001e  e01e              B        |L7.94|
                  |L7.32|
;;;629        {
;;;630    				case 0:
;;;631    				{
;;;632    						Data_Temp |= ( uint32_t ) Data;
000020  4319              ORRS     r1,r1,r3
;;;633    						break;
000022  e001              B        |L7.40|
                  |L7.36|
;;;634    				}
;;;635    				case 1:
;;;636    				{
;;;637    						return FALSE;  //The address is misaligned, wrong
;;;638    				}
;;;639    				case 2:
;;;640    				{
;;;641    						Data_Temp |= ( uint32_t ) ( Data << 16 );
000024  041a              LSLS     r2,r3,#16
000026  4311              ORRS     r1,r1,r2
                  |L7.40|
;;;642    						break;
;;;643    				}
;;;644    				case 3:
;;;645    				{
;;;646    						return FALSE;  //The address is misaligned, wrong
;;;647    				}
;;;648        }
;;;649        /* Check if the system clock source is HIRC, if using HIRC as system clock, 
;;;650    	     directly write data to FLASH memory at the specified address */
;;;651    		if(((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSW)==RESET)\
000028  4a0e              LDR      r2,|L7.100|
00002a  6953              LDR      r3,[r2,#0x14]
00002c  061c              LSLS     r4,r3,#24
;;;652    			 ||(((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSW)!=RESET)&&((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSEL)==(0x2UL << RCC_CFG0_SYSCLKSEL_Pos))))
;;;653    		{
;;;654    				/*Write incoming data*/
;;;655    				/* Check if software lock is open (IAP write operations are permitted) */
;;;656    				if(IapWriteFlag==IAP_ENABLE)
00002e  4b0e              LDR      r3,|L7.104|
000030  d50b              BPL      |L7.74|
000032  6954              LDR      r4,[r2,#0x14]         ;652
000034  0624              LSLS     r4,r4,#24             ;652
000036  d504              BPL      |L7.66|
000038  6952              LDR      r2,[r2,#0x14]         ;652
00003a  0592              LSLS     r2,r2,#22             ;652
00003c  0f92              LSRS     r2,r2,#30             ;652
00003e  2a02              CMP      r2,#2                 ;652
000040  d003              BEQ      |L7.74|
                  |L7.66|
;;;657    				{
;;;658    						* ( __IO uint32_t* ) Addr_Temp = Data_Temp;
;;;659    				}
;;;660    				/* Verify the data was written correctly by reading it back */
;;;661    				if ( Data_Temp == * ( __IO uint32_t * ) Addr_Temp )
;;;662    						return TRUE;
;;;663    				else
;;;664    						return FALSE;
;;;665    		}
;;;666    		/* If not using HIRC as system clock, we need to jump to the function pointer pWriteIapFun
;;;667           which points to the IAP write function that was previously copied to RAM */
;;;668    		else
;;;669    		{
;;;670    				boolType Flag;
;;;671    			  /* Execute the IAP write function from RAM via the function pointer */
;;;672    				Flag=(*pWriteIapFun)(Addr_Temp,Data_Temp,IAP_WORD);
000042  681b              LDR      r3,[r3,#0]  ; pWriteIapFun
000044  bc30              POP      {r4,r5}
000046  2202              MOVS     r2,#2
000048  4718              BX       r3
                  |L7.74|
00004a  685a              LDR      r2,[r3,#4]            ;656  ; IapWriteFlag
00004c  2a69              CMP      r2,#0x69              ;656
00004e  d100              BNE      |L7.82|
000050  6001              STR      r1,[r0,#0]            ;658
                  |L7.82|
000052  6800              LDR      r0,[r0,#0]            ;661
000054  4288              CMP      r0,r1                 ;661
000056  d102              BNE      |L7.94|
000058  2001              MOVS     r0,#1                 ;662
                  |L7.90|
;;;673    			  /* Return the result from the RAM-executed function */
;;;674    				return Flag;
;;;675    		}
;;;676    }
00005a  bc30              POP      {r4,r5}
00005c  4770              BX       lr
                  |L7.94|
00005e  2000              MOVS     r0,#0                 ;664
000060  e7fb              B        |L7.90|
;;;677    #endif
                          ENDP

000062  0000              DCW      0x0000
                  |L7.100|
                          DCD      0x40003000
                  |L7.104|
                          DCD      ||.data||

                          AREA ||i.IAP_ProgramWord||, CODE, READONLY, ALIGN=2

                  IAP_ProgramWord PROC
;;;509      */
;;;510    boolType IAP_ProgramWord ( uint32_t Address, uint32_t Data )
000000  b430              PUSH     {r4,r5}
;;;511    {
;;;512        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;513    		
;;;514    		/* Check if the system clock source is HIRC, if using HIRC as system clock, 
;;;515    	     directly write data to FLASH memory at the specified address */
;;;516    		if(((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSW)==RESET)\
000002  4a0e              LDR      r2,|L8.60|
000004  6953              LDR      r3,[r2,#0x14]
000006  061c              LSLS     r4,r3,#24
;;;517    			 ||(((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSW)!=RESET)&&((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSEL)==(0x2UL << RCC_CFG0_SYSCLKSEL_Pos))))
;;;518    		{
;;;519    				/* Check if software lock is open (IAP write operations are permitted) */
;;;520    				if(IapWriteFlag==IAP_ENABLE)
000008  4b0d              LDR      r3,|L8.64|
00000a  d50b              BPL      |L8.36|
00000c  6954              LDR      r4,[r2,#0x14]         ;517
00000e  0624              LSLS     r4,r4,#24             ;517
000010  d504              BPL      |L8.28|
000012  6952              LDR      r2,[r2,#0x14]         ;517
000014  0592              LSLS     r2,r2,#22             ;517
000016  0f92              LSRS     r2,r2,#30             ;517
000018  2a02              CMP      r2,#2                 ;517
00001a  d003              BEQ      |L8.36|
                  |L8.28|
;;;521    				{
;;;522    						* ( __IO uint32_t* ) Address = Data;
;;;523    				}
;;;524    				/* Verify the data was written correctly by reading it back */
;;;525    				if ( Data == * ( __IO uint32_t * ) Address )
;;;526    						return TRUE;
;;;527    				else
;;;528    						return FALSE;
;;;529    		}
;;;530    		/* If not using HIRC as system clock, we need to jump to the function pointer pWriteIapFun 
;;;531    		   which points to the IAP write function that was previously copied to RAM */
;;;532    		else
;;;533    		{
;;;534    				boolType Flag;
;;;535    				/* Execute the IAP write function from RAM via the function pointer */
;;;536    				Flag=(*pWriteIapFun)(Address,Data,IAP_WORD);
00001c  681b              LDR      r3,[r3,#0]  ; pWriteIapFun
00001e  bc30              POP      {r4,r5}
000020  2202              MOVS     r2,#2
000022  4718              BX       r3
                  |L8.36|
000024  685a              LDR      r2,[r3,#4]            ;520  ; IapWriteFlag
000026  2a69              CMP      r2,#0x69              ;520
000028  d100              BNE      |L8.44|
00002a  6001              STR      r1,[r0,#0]            ;522
                  |L8.44|
00002c  6800              LDR      r0,[r0,#0]            ;525
00002e  4288              CMP      r0,r1                 ;525
000030  d102              BNE      |L8.56|
000032  2001              MOVS     r0,#1                 ;526
                  |L8.52|
;;;537    				/* Return the result from the RAM-executed function */
;;;538    				return Flag;
;;;539    		}
;;;540    }
000034  bc30              POP      {r4,r5}
000036  4770              BX       lr
                  |L8.56|
000038  2000              MOVS     r0,#0                 ;528
00003a  e7fb              B        |L8.52|
;;;541    
                          ENDP

                  |L8.60|
                          DCD      0x40003000
                  |L8.64|
                          DCD      ||.data||

                          AREA ||i.IAP_ProgramWordArray||, CODE, READONLY, ALIGN=2

                  IAP_ProgramWordArray PROC
;;;732      */
;;;733    uint16_t IAP_ProgramWordArray ( uint32_t Address, uint32_t* ByteArray, uint16_t ArraySize )
000000  b5f0              PUSH     {r4-r7,lr}
;;;734    {
000002  460d              MOV      r5,r1
;;;735        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;736    		/* Counter for successfully programmed words */
;;;737        uint16_t tmpCnt = 0;
;;;738    		/* Check if the system clock source is HIRC, if using HIRC as system clock, 
;;;739    	     directly write data to FLASH memory at the specified address */
;;;740    		if(((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSW)==RESET)\
000004  4921              LDR      r1,|L9.140|
000006  4616              MOV      r6,r2                 ;734
000008  4604              MOV      r4,r0                 ;734
00000a  694a              LDR      r2,[r1,#0x14]
00000c  b0c1              SUB      sp,sp,#0x104          ;734
00000e  2000              MOVS     r0,#0                 ;737
000010  0612              LSLS     r2,r2,#24
000012  d527              BPL      |L9.100|
;;;741    			 ||(((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSW)!=RESET)&&((RCC->RCC_CFG0 &( uint32_t )RCC_CFG0_SYSCLKSEL)==(0x2UL << RCC_CFG0_SYSCLKSEL_Pos))))
000014  694a              LDR      r2,[r1,#0x14]
000016  0612              LSLS     r2,r2,#24
000018  d504              BPL      |L9.36|
00001a  6949              LDR      r1,[r1,#0x14]
00001c  0589              LSLS     r1,r1,#22
00001e  0f89              LSRS     r1,r1,#30
000020  2902              CMP      r1,#2
000022  d01f              BEQ      |L9.100|
                  |L9.36|
;;;742    		{
;;;743    				/* Check if address is 32-bit aligned (required for word programming) */
;;;744    				if ( ( Address & 0x03 ) == 0 )
;;;745    				{
;;;746    						/* Check if software lock is open (IAP write operations are permitted) */
;;;747    						if(IapWriteFlag==IAP_ENABLE)
;;;748    						{
;;;749    								/* Program each word in the array until completion or error */
;;;750    								do
;;;751    								{
;;;752    										* ( __IO uint32_t* ) Address = ByteArray[tmpCnt];
;;;753    										/* Verify the write operation by reading back the value */
;;;754    										if ( ByteArray[tmpCnt] != * ( __IO uint32_t * ) Address )
;;;755    												break;
;;;756    										/* Move to next 32-bit address */
;;;757    										Address = Address + 4;
;;;758    								/* Continue until all words are programmed */
;;;759    								} while ( ++tmpCnt < ArraySize );
;;;760    						}
;;;761    				}
;;;762    				/* Return count of successfully programmed words */
;;;763    				return tmpCnt;
;;;764    		}
;;;765    		/* If not using HIRC as system clock, we need to jump to the function pointer pWriteIapFun
;;;766           which points to the IAP write function that was previously copied to RAM */
;;;767    		else
;;;768    		{
;;;769    				/* Define function pointer type for the RAM-based IAP programming function */
;;;770    				typedef uint16_t (*pInitFlashInRam)( uint32_t Address, uint8_t* ByteArray, uint16_t ArraySize,IAPWRITE_ALIGNTYPE Type );
;;;771    				/* Allocate and initialize RAM buffer for the IAP programming function */
;;;772    				__ALIGNED(4) uint8_t IapWriteInRam[256]={0};
000024  21ff              MOVS     r1,#0xff
000026  3101              ADDS     r1,#1
000028  4668              MOV      r0,sp
00002a  f7fffffe          BL       __aeabi_memclr4
;;;773    				/* Copy the IAP programming function from FLASH to RAM */
;;;774    				for(uint16_t i=0;i<sizeof(IapWriteInRam);i++)
;;;775    				{
;;;776    						IapWriteInRam[i] =*(uint8_t*)((uint32_t)IAP_ProgramArray_InRam-1+i);
00002e  4a18              LDR      r2,|L9.144|
000030  2300              MOVS     r3,#0                 ;774
000032  4668              MOV      r0,sp                 ;772
                  |L9.52|
000034  18d1              ADDS     r1,r2,r3
000036  3920              SUBS     r1,r1,#0x20
000038  7fc9              LDRB     r1,[r1,#0x1f]
00003a  54c1              STRB     r1,[r0,r3]
00003c  1c5b              ADDS     r3,r3,#1
00003e  b29b              UXTH     r3,r3                 ;774
000040  2bff              CMP      r3,#0xff              ;774
000042  d9f7              BLS      |L9.52|
;;;777    				}
;;;778    				/* Create function pointer to the RAM-based function and execute it */
;;;779    				/* The "|0x01" operation sets the Thumb bit for ARM architecture compatibility.
;;;780    				   In ARM architecture, the least significant bit (LSB) of a function pointer
;;;781    				   indicates the instruction set (0 for ARM, 1 for Thumb). This ensures the
;;;782    				   function executes in Thumb mode, which is typically used for RAM-based code.*/
;;;783    				pInitFlashInRam p=(pInitFlashInRam)((uint32_t)IapWriteInRam|0x01);
000044  1c47              ADDS     r7,r0,#1
;;;784    				tmpCnt =(*p)(Address,(uint8_t*)ByteArray,ArraySize,IAP_WORD);
000046  2302              MOVS     r3,#2
000048  4632              MOV      r2,r6
00004a  4629              MOV      r1,r5
00004c  4620              MOV      r0,r4
00004e  47b8              BLX      r7
;;;785    				/* Clear the RAM buffer */
;;;786    				for(uint16_t i=0;i<sizeof(IapWriteInRam);i++)
000050  2100              MOVS     r1,#0
000052  460b              MOV      r3,r1
000054  466a              MOV      r2,sp                 ;772
                  |L9.86|
;;;787    				{
;;;788    						IapWriteInRam[i] =0;
000056  5453              STRB     r3,[r2,r1]
000058  1c49              ADDS     r1,r1,#1
00005a  b289              UXTH     r1,r1                 ;786
00005c  29ff              CMP      r1,#0xff              ;786
00005e  d9fa              BLS      |L9.86|
                  |L9.96|
;;;789    				}
;;;790    				/* Return count of successfully programmed words */
;;;791    				return tmpCnt;		
;;;792    		}
;;;793    }
000060  b041              ADD      sp,sp,#0x104
000062  bdf0              POP      {r4-r7,pc}
                  |L9.100|
000064  07a1              LSLS     r1,r4,#30             ;744
000066  d1fb              BNE      |L9.96|
000068  490a              LDR      r1,|L9.148|
00006a  6849              LDR      r1,[r1,#4]            ;747  ; IapWriteFlag
00006c  2969              CMP      r1,#0x69              ;747
00006e  d1f7              BNE      |L9.96|
                  |L9.112|
000070  0081              LSLS     r1,r0,#2              ;752
000072  586a              LDR      r2,[r5,r1]            ;752
000074  6022              STR      r2,[r4,#0]            ;752
000076  5869              LDR      r1,[r5,r1]            ;754
000078  6822              LDR      r2,[r4,#0]            ;754
00007a  4291              CMP      r1,r2                 ;754
00007c  d1f0              BNE      |L9.96|
00007e  1c40              ADDS     r0,r0,#1              ;754
000080  b280              UXTH     r0,r0                 ;759
000082  1d24              ADDS     r4,r4,#4              ;759
000084  42b0              CMP      r0,r6                 ;759
000086  d3f3              BCC      |L9.112|
000088  e7ea              B        |L9.96|
;;;794    #endif
                          ENDP

00008a  0000              DCW      0x0000
                  |L9.140|
                          DCD      0x40003000
                  |L9.144|
                          DCD      IAP_ProgramArray_InRam
                  |L9.148|
                          DCD      ||.data||

                          AREA ||i.IAP_Program_InRam||, CODE, READONLY, ALIGN=2

                  IAP_Program_InRam PROC
;;;105     */  
;;;106    static boolType IAP_Program_InRam(uint32_t Address, uint32_t Data,IAPWRITE_ALIGNTYPE Type)
000000  b5f0              PUSH     {r4-r7,lr}
;;;107    {
;;;108    		boolType Flag;
;;;109    		/* Disable non-maskable interrupts */
;;;110    		uint32_t	Temp=RCC->NMI_CFG;
000002  4f14              LDR      r7,|L10.84|
000004  6afb              LDR      r3,[r7,#0x2c]
;;;111    		Temp =(Temp&0x0000FFFF)|0xA05F0000;
000006  4c14              LDR      r4,|L10.88|
000008  b29b              UXTH     r3,r3
00000a  191b              ADDS     r3,r3,r4
;;;112    		RCC->NMI_CFG =Temp&0xFFFF0000;
00000c  0c1c              LSRS     r4,r3,#16
00000e  0424              LSLS     r4,r4,#16
000010  62fc              STR      r4,[r7,#0x2c]
;;;113    		/* Disable interrupt requests (IRQ) */
;;;114    		__disable_irq();
000012  b672              CPSID    i
;;;115    		
;;;116    		/* Enable writing if the IAP software lock is open */
;;;117        /* IAP_WriteCmd(ENABLE); */
;;;118    		if(IapWriteFlag==IAP_ENABLE)
000014  4c11              LDR      r4,|L10.92|
;;;119    		{
;;;120    				IAP->IAP_CON |= ( uint32_t ) IAP_CON_PRG;
000016  4e12              LDR      r6,|L10.96|
000018  6865              LDR      r5,[r4,#4]  ; IapWriteFlag
00001a  2410              MOVS     r4,#0x10
00001c  2d69              CMP      r5,#0x69              ;118
00001e  d112              BNE      |L10.70|
000020  68f5              LDR      r5,[r6,#0xc]
000022  4325              ORRS     r5,r5,r4
000024  60f5              STR      r5,[r6,#0xc]
;;;121    		}
;;;122    		if(IapWriteFlag==IAP_ENABLE)
;;;123    		{
;;;124    				switch(Type)
000026  2a00              CMP      r2,#0
000028  d004              BEQ      |L10.52|
00002a  2a01              CMP      r2,#1
00002c  d005              BEQ      |L10.58|
00002e  2a02              CMP      r2,#2
000030  d109              BNE      |L10.70|
000032  e005              B        |L10.64|
                  |L10.52|
;;;125    				{
;;;126    						/* Program a byte (8-bit) at a specified address */
;;;127    						case IAP_BYTE:
;;;128    						{
;;;129    								* ( uint8_t * ) Address = (uint8_t)Data;
;;;130    								* ( uint8_t * ) Address = (uint8_t)Data;
000034  7001              STRB     r1,[r0,#0]
;;;131    								if ( (uint8_t)Data == * ( __IO uint8_t * ) Address )
000036  7800              LDRB     r0,[r0,#0]
000038  e004              B        |L10.68|
                  |L10.58|
;;;132    										Flag= TRUE;
;;;133    								else
;;;134    										Flag= FALSE;
;;;135    								break;
;;;136    						}
;;;137    						/* Program a halfword (16-bit) at a specified address */
;;;138    						case IAP_HALFWORD:
;;;139    						{
;;;140    								* ( uint16_t * ) Address = (uint16_t)Data;
;;;141    								* ( uint16_t * ) Address = (uint16_t)Data;
00003a  8001              STRH     r1,[r0,#0]
;;;142    								if ( (uint16_t)Data == * ( __IO uint16_t * ) Address )
00003c  8800              LDRH     r0,[r0,#0]
00003e  e001              B        |L10.68|
                  |L10.64|
;;;143    										Flag= TRUE;
;;;144    								else
;;;145    										Flag= FALSE;						
;;;146    								break;
;;;147    						}			
;;;148    						/* Program a word (32-bit) at a specified address */
;;;149    						case IAP_WORD:
;;;150    						{
;;;151    								* ( uint32_t * ) Address = (uint32_t)Data;
;;;152    								* ( uint32_t * ) Address = (uint32_t)Data;
;;;153    								if ( (uint32_t)Data == * ( __IO uint32_t * ) Address )
000040  6001              STR      r1,[r0,#0]
000042  6800              LDR      r0,[r0,#0]
                  |L10.68|
;;;154    										Flag= TRUE;
000044  2001              MOVS     r0,#1
                  |L10.70|
;;;155    								else
;;;156    										Flag= FALSE;						
;;;157    								break;
;;;158    						}
;;;159    				}
;;;160    		}
;;;161    		/* IAP_WriteCmd(DISABLE); */
;;;162        IAP->IAP_CON &= ( uint32_t ) ~IAP_CON_PRG;		
000046  68f1              LDR      r1,[r6,#0xc]
000048  43a1              BICS     r1,r1,r4
00004a  60f1              STR      r1,[r6,#0xc]
;;;163    		/* Enable interrupt requests (IRQ) */
;;;164        __enable_irq();
00004c  b662              CPSIE    i
;;;165    		/* Restore the previous non-maskable interrupt (NMI) settings */
;;;166    		RCC->NMI_CFG =Temp; 
00004e  62fb              STR      r3,[r7,#0x2c]
;;;167    		return Flag;
;;;168    }	
000050  bdf0              POP      {r4-r7,pc}
;;;169    
                          ENDP

000052  0000              DCW      0x0000
                  |L10.84|
                          DCD      0x40003000
                  |L10.88|
                          DCD      0xa05f0000
                  |L10.92|
                          DCD      ||.data||
                  |L10.96|
                          DCD      0x400003c0

                          AREA ||i.IAP_ReadByte||, CODE, READONLY, ALIGN=1

                  IAP_ReadByte PROC
;;;714      */
;;;715    uint8_t IAP_ReadByte ( uint32_t Address )
000000  7800              LDRB     r0,[r0,#0]
;;;716    {
;;;717        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;718    
;;;719        uint8_t Data;
;;;720        Data = * ( uint8_t* ) Address;
;;;721        return Data;
;;;722    }
000002  4770              BX       lr
;;;723    
                          ENDP


                          AREA ||i.IAP_ReadByteArray||, CODE, READONLY, ALIGN=1

                  IAP_ReadByteArray PROC
;;;1059     */
;;;1060   uint16_t IAP_ReadByteArray ( uint32_t Address, uint8_t* ByteArray, uint16_t ArraySize )
000000  b510              PUSH     {r4,lr}
;;;1061   {
000002  4603              MOV      r3,r0
;;;1062       assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;1063   
;;;1064       uint16_t tmpCnt = 0;
000004  2000              MOVS     r0,#0
                  |L12.6|
;;;1065       do
;;;1066       {
;;;1067           ByteArray[tmpCnt] = * ( __IO uint8_t* ) Address;
000006  781c              LDRB     r4,[r3,#0]
000008  540c              STRB     r4,[r1,r0]
00000a  1c40              ADDS     r0,r0,#1
;;;1068           Address = Address + 1;
;;;1069   
;;;1070       } while ( ++tmpCnt < ArraySize );
00000c  b280              UXTH     r0,r0
00000e  1c5b              ADDS     r3,r3,#1
000010  4290              CMP      r0,r2
000012  d3f8              BCC      |L12.6|
;;;1071   
;;;1072       return tmpCnt;
;;;1073   }
000014  bd10              POP      {r4,pc}
;;;1074   
                          ENDP


                          AREA ||i.IAP_ReadHalfWord||, CODE, READONLY, ALIGN=1

                  IAP_ReadHalfWord PROC
;;;699      */
;;;700    uint16_t IAP_ReadHalfWord ( uint32_t Address )
000000  8800              LDRH     r0,[r0,#0]
;;;701    {
;;;702        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;703    
;;;704        uint16_t Data;
;;;705        Data = * ( __IO uint16_t* ) Address;
;;;706        return Data;
;;;707    }
000002  4770              BX       lr
;;;708    
                          ENDP


                          AREA ||i.IAP_ReadHalfWordArray||, CODE, READONLY, ALIGN=1

                  IAP_ReadHalfWordArray PROC
;;;1034     */
;;;1035   uint16_t IAP_ReadHalfWordArray ( uint32_t Address, uint16_t* ByteArray, uint16_t ArraySize )
000000  b530              PUSH     {r4,r5,lr}
;;;1036   {
000002  4603              MOV      r3,r0
;;;1037       assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;1038   
;;;1039       uint16_t tmpCnt = 0;
000004  2000              MOVS     r0,#0
;;;1040       if ( ( Address & 0x01 ) == 0 )
000006  07dc              LSLS     r4,r3,#31
000008  d107              BNE      |L14.26|
                  |L14.10|
;;;1041       {
;;;1042           do
;;;1043           {
;;;1044               ByteArray[tmpCnt] = * ( __IO uint16_t* ) Address;
00000a  881c              LDRH     r4,[r3,#0]
00000c  0045              LSLS     r5,r0,#1
00000e  1c40              ADDS     r0,r0,#1
;;;1045               Address = Address + 2;
;;;1046   
;;;1047           } while ( ++tmpCnt < ArraySize );
000010  b280              UXTH     r0,r0
000012  1c9b              ADDS     r3,r3,#2
000014  534c              STRH     r4,[r1,r5]            ;1044
000016  4290              CMP      r0,r2
000018  d3f7              BCC      |L14.10|
                  |L14.26|
;;;1048       }
;;;1049       return tmpCnt;
;;;1050   }
00001a  bd30              POP      {r4,r5,pc}
;;;1051   
                          ENDP


                          AREA ||i.IAP_ReadWord||, CODE, READONLY, ALIGN=1

                  IAP_ReadWord PROC
;;;684      */
;;;685    uint32_t IAP_ReadWord ( uint32_t Address )
000000  6800              LDR      r0,[r0,#0]
;;;686    {
;;;687        assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;688    
;;;689        uint32_t Data;
;;;690        Data = * ( __IO uint32_t* ) Address;
;;;691        return Data;
;;;692    }
000002  4770              BX       lr
;;;693    
                          ENDP


                          AREA ||i.IAP_ReadWordArray||, CODE, READONLY, ALIGN=1

                  IAP_ReadWordArray PROC
;;;1009     */
;;;1010   uint16_t IAP_ReadWordArray ( uint32_t Address, uint32_t* ByteArray, uint16_t ArraySize )
000000  b530              PUSH     {r4,r5,lr}
;;;1011   {
000002  4603              MOV      r3,r0
;;;1012       assert_param ( IS_IAP_ADDRESS ( Address ) );
;;;1013   
;;;1014       uint16_t tmpCnt = 0;
000004  2000              MOVS     r0,#0
;;;1015       if ( ( Address & 0x03 ) == 0 )
000006  079c              LSLS     r4,r3,#30
000008  d106              BNE      |L16.24|
                  |L16.10|
;;;1016       {
;;;1017           do
;;;1018           {
;;;1019               ByteArray[tmpCnt] = * ( __IO uint32_t* ) Address;
00000a  cb10              LDM      r3!,{r4}
00000c  0085              LSLS     r5,r0,#2
00000e  1c40              ADDS     r0,r0,#1
;;;1020               Address = Address + 4;
;;;1021   
;;;1022           } while ( ++tmpCnt < ArraySize );
000010  b280              UXTH     r0,r0
000012  514c              STR      r4,[r1,r5]            ;1019
000014  4290              CMP      r0,r2
000016  d3f8              BCC      |L16.10|
                  |L16.24|
;;;1023       }
;;;1024       return tmpCnt;
;;;1025   }
000018  bd30              POP      {r4,r5,pc}
;;;1026   
                          ENDP


                          AREA ||i.IAP_SoftwareReset||, CODE, READONLY, ALIGN=2

                  IAP_SoftwareReset PROC
;;;1098     */
;;;1099   void IAP_SoftwareReset ( IAP_BTLD_TypeDef IAP_BTLDType )
000000  21ff              MOVS     r1,#0xff
;;;1100   {
;;;1101       IAP->IAP_CON = ( IAP_BTLDType | IAP_CON_RST );
000002  3101              ADDS     r1,#1
000004  4308              ORRS     r0,r0,r1
000006  4901              LDR      r1,|L17.12|
000008  60c8              STR      r0,[r1,#0xc]
;;;1102   }
00000a  4770              BX       lr
;;;1103   
                          ENDP

                  |L17.12|
                          DCD      0x400003c0

                          AREA ||i.IAP_Unlock||, CODE, READONLY, ALIGN=2

                  IAP_Unlock PROC
;;;265      */
;;;266    boolType IAP_Unlock ( void )
000000  b530              PUSH     {r4,r5,lr}
;;;267    {
;;;268    		/* Check if software lock is open (IAP write operations are permitted) */
;;;269    		if(IapWriteFlag==IAP_ENABLE)
000002  4c0e              LDR      r4,|L18.60|
;;;270    		{
;;;271    #if defined(SC32f10xx)
;;;272    				/* HIRC must be enabled before IAP operation */
;;;273    				RCC_Unlock ( 0xFF );
;;;274    				RCC_HIRCCmd ( ENABLE );
;;;275    #endif
;;;276    				/* Authorize the FLASH Registers access */
;;;277    				IAP->IAPKEY = IAP_KEY1;
000004  4b0e              LDR      r3,|L18.64|
000006  6860              LDR      r0,[r4,#4]            ;269  ; IapWriteFlag
000008  2869              CMP      r0,#0x69              ;269
00000a  d111              BNE      |L18.48|
00000c  480d              LDR      r0,|L18.68|
00000e  6018              STR      r0,[r3,#0]
;;;278    				IAP->IAPKEY = IAP_KEY2;
000010  480d              LDR      r0,|L18.72|
000012  6018              STR      r0,[r3,#0]
000014  490d              LDR      r1,|L18.76|
000016  4d0e              LDR      r5,|L18.80|
000018  2000              MOVS     r0,#0
                  |L18.26|
00001a  180a              ADDS     r2,r1,r0
00001c  3a20              SUBS     r2,r2,#0x20
00001e  7fd2              LDRB     r2,[r2,#0x1f]
000020  542a              STRB     r2,[r5,r0]
000022  1c40              ADDS     r0,r0,#1
000024  b280              UXTH     r0,r0
000026  28b4              CMP      r0,#0xb4
000028  d3f7              BCC      |L18.26|
00002a  4809              LDR      r0,|L18.80|
00002c  1c40              ADDS     r0,r0,#1
00002e  6020              STR      r0,[r4,#0]  ; pWriteIapFun
                  |L18.48|
;;;279    	
;;;280    				InitFlashToRam();
;;;281    		}
;;;282    		if ( IAP->IAPKEY == 0x01 )
000030  6818              LDR      r0,[r3,#0]
000032  2801              CMP      r0,#1
000034  d000              BEQ      |L18.56|
;;;283    				/* Unlock success */
;;;284    				return TRUE;
;;;285    		else
;;;286    				/* Unlock Error */
;;;287    				return FALSE;
000036  2000              MOVS     r0,#0
                  |L18.56|
;;;288    }
000038  bd30              POP      {r4,r5,pc}
;;;289    
                          ENDP

00003a  0000              DCW      0x0000
                  |L18.60|
                          DCD      ||.data||
                  |L18.64|
                          DCD      0x400003c0
                  |L18.68|
                          DCD      0x12345678
                  |L18.72|
                          DCD      0xa05f05fa
                  |L18.76|
                          DCD      IAP_Program_InRam
                  |L18.80|
                          DCD      ||.bss||

                          AREA ||i.IAP_WriteCmd||, CODE, READONLY, ALIGN=2

                  IAP_WriteCmd PROC
;;;309      */
;;;310    void IAP_WriteCmd ( FunctionalState NewState )
000000  4907              LDR      r1,|L19.32|
;;;311    {
;;;312        /* Check the parameters */
;;;313        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;314    
;;;315        if ( NewState != DISABLE )
;;;316        {
;;;317    				/* Check if software lock is open (IAP write operations are permitted) */
;;;318    				if(IapWriteFlag==IAP_ENABLE)
;;;319    				{
;;;320    						IAP->IAP_CON |= ( uint32_t ) IAP_CON_PRG;
000002  2210              MOVS     r2,#0x10
000004  2800              CMP      r0,#0                 ;315
000006  d007              BEQ      |L19.24|
000008  4806              LDR      r0,|L19.36|
00000a  6840              LDR      r0,[r0,#4]            ;318  ; IapWriteFlag
00000c  2869              CMP      r0,#0x69              ;318
00000e  d102              BNE      |L19.22|
000010  68c8              LDR      r0,[r1,#0xc]
000012  4310              ORRS     r0,r0,r2
                  |L19.20|
;;;321    				}
;;;322        }
;;;323        else
;;;324        {
;;;325            IAP->IAP_CON &= ~ ( uint32_t ) IAP_CON_PRG;
000014  60c8              STR      r0,[r1,#0xc]
                  |L19.22|
;;;326        }
;;;327    }
000016  4770              BX       lr
                  |L19.24|
000018  68c8              LDR      r0,[r1,#0xc]          ;325
00001a  4390              BICS     r0,r0,r2              ;325
00001c  e7fa              B        |L19.20|
;;;328    
                          ENDP

00001e  0000              DCW      0x0000
                  |L19.32|
                          DCD      0x400003c0
                  |L19.36|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  IapProgramInRam
                          %        180

                          AREA ||.data||, DATA, ALIGN=2

                  pWriteIapFun
                          DCD      IAP_NOP
                  IapWriteFlag
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_iap.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_iap_c_c6871858____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_iap_c_c6871858____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_iap_c_c6871858____REVSH|
#line 478
|__asm___15_sc32f1xxx_iap_c_c6871858____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
