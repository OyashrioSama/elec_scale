; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: armcc [4d365d]
; commandline armcc [--c99 --list --split_sections --debug -c --asm --interleave -o..\Output\sc32f1xxx_pwm.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\Output\sc32f1xxx_pwm.d --cpu=Cortex-M0+ --apcs=interwork --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -D__UVISION_VERSION=536 -DSC32f12xx --omf_browse=..\Output\sc32f1xxx_pwm.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_pwm.c]
                          THUMB

                          AREA ||i.PWM_ClearFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearFlag PROC
;;;507     */
;;;508    void PWM_ClearFlag ( PWM_TypeDef* PWMx, uint16_t PWM_FLAG )
000000  6081              STR      r1,[r0,#8]
;;;509    {
;;;510        /* Check the parameters */
;;;511        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;512        assert_param ( IS_GET_PWM_FLAG ( PWM_FLAG ) );
;;;513    
;;;514        /* Clear the flags */
;;;515        PWMx->PWM_STS = ( uint16_t ) PWM_FLAG;
;;;516    }
000002  4770              BX       lr
;;;517    
                          ENDP


                          AREA ||i.PWM_Cmd||, CODE, READONLY, ALIGN=2

                  PWM_Cmd PROC
;;;177     */
;;;178    void PWM_Cmd ( PWM_TypeDef* PWMx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;179    {
;;;180        /* Check the parameters */
;;;181        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;182        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;183    
;;;184        if ( NewState != DISABLE )
;;;185        {
;;;186            /* Enable the PWM Counter */
;;;187            PWMx->PWM_CON |= PWM_CON_ENPWM;
;;;188        }
;;;189        else
;;;190        {
;;;191            /* Disable the PWM Counter */
;;;192            PWMx->PWM_CON &= ( uint16_t ) ~PWM_CON_ENPWM;
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L2.12|
000006  2280              MOVS     r2,#0x80              ;187
000008  4311              ORRS     r1,r1,r2              ;187
00000a  e001              B        |L2.16|
                  |L2.12|
00000c  4a01              LDR      r2,|L2.20|
00000e  4011              ANDS     r1,r1,r2
                  |L2.16|
000010  6001              STR      r1,[r0,#0]            ;187
;;;193        }
;;;194    }
000012  4770              BX       lr
;;;195    
                          ENDP

                  |L2.20|
                          DCD      0x0000ff7f

                          AREA ||i.PWM_DeInit||, CODE, READONLY, ALIGN=2

                  PWM_DeInit PROC
;;;46      */
;;;47     void PWM_DeInit ( PWM_TypeDef* PWMx )
000000  4906              LDR      r1,|L3.28|
;;;48     {
000002  b510              PUSH     {r4,lr}
;;;49         /* Check the parameters */
;;;50         assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;51     
;;;52         if ( PWMx == PWM0 )
000004  4288              CMP      r0,r1
000006  d108              BNE      |L3.26|
;;;53         {
;;;54             /* Enable PWM reset state */
;;;55             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_PWM0, ENABLE );
000008  1584              ASRS     r4,r0,#22
00000a  2101              MOVS     r1,#1
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;56             /* Enable PWM reset state */
;;;57             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_PWM0, DISABLE );
000012  2100              MOVS     r1,#0
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       RCC_APB0PeriphResetCmd
                  |L3.26|
;;;58         }
;;;59     }
00001a  bd10              POP      {r4,pc}
;;;60     
                          ENDP

                  |L3.28|
                          DCD      0x40020200

                          AREA ||i.PWM_FDCmd||, CODE, READONLY, ALIGN=2

                  PWM_FDCmd PROC
;;;408     */
;;;409    void PWM_FDCmd ( PWM_TypeDef* PWMx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;410    {
;;;411        /* Check the parameters */
;;;412        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;413        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;414    
;;;415        if ( NewState != DISABLE )
;;;416        {
;;;417            /* Enable the PWM Fault Dectection */
;;;418            PWMx->PWM_FLT |= PWM_FLT_FLTEN;
;;;419        }
;;;420        else
;;;421        {
;;;422            /* Disable the PWM Fault Dectection */
;;;423            PWMx->PWM_FLT &= ( uint16_t ) ~PWM_FLT_FLTEN;
000002  6941              LDR      r1,[r0,#0x14]
000004  d002              BEQ      |L4.12|
000006  2280              MOVS     r2,#0x80              ;418
000008  4311              ORRS     r1,r1,r2              ;418
00000a  e001              B        |L4.16|
                  |L4.12|
00000c  4a01              LDR      r2,|L4.20|
00000e  4011              ANDS     r1,r1,r2
                  |L4.16|
000010  6141              STR      r1,[r0,#0x14]         ;418
;;;424        }
;;;425    }
000012  4770              BX       lr
;;;426    /**
                          ENDP

                  |L4.20|
                          DCD      0x0000ff7f

                          AREA ||i.PWM_FDInit||, CODE, READONLY, ALIGN=1

                  PWM_FDInit PROC
;;;390     */
;;;391    void PWM_FDInit ( PWM_TypeDef* PWMx, PWM_FDInitTypeDef* PWM_FDInitStruct )
000000  6942              LDR      r2,[r0,#0x14]
;;;392    {
;;;393        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;394    
;;;395        PWMx->PWM_FLT &= ( uint32_t ) ~ ( PWM_FLT_FLTDT | PWM_FLT_FLTTV | PWM_FLT_FLTMD );
000002  2333              MOVS     r3,#0x33
000004  439a              BICS     r2,r2,r3
000006  6142              STR      r2,[r0,#0x14]
;;;396        PWMx->PWM_FLT |= ( uint32_t ) ( PWM_FDInitStruct->PWM_FDFilteringTime | PWM_FDInitStruct->PWM_FDMode |
000008  6942              LDR      r2,[r0,#0x14]
00000a  888b              LDRH     r3,[r1,#4]
00000c  431a              ORRS     r2,r2,r3
00000e  880b              LDRH     r3,[r1,#0]
000010  8849              LDRH     r1,[r1,#2]
000012  430b              ORRS     r3,r3,r1
000014  431a              ORRS     r2,r2,r3
000016  6142              STR      r2,[r0,#0x14]
;;;397                                        PWM_FDInitStruct->PWM_FDVoltage );
;;;398    }
000018  4770              BX       lr
;;;399    
                          ENDP


                          AREA ||i.PWM_FDStructInit||, CODE, READONLY, ALIGN=1

                  PWM_FDStructInit PROC
;;;375      */
;;;376    void PWM_FDStructInit ( PWM_FDInitTypeDef* PWM_FDInitStruct )
000000  2100              MOVS     r1,#0
;;;377    {
;;;378        /* Set the default configuration */
;;;379        PWM_FDInitStruct->PWM_FDFilteringTime = PWM_FilteringTime_0us;
000002  8081              STRH     r1,[r0,#4]
;;;380        PWM_FDInitStruct->PWM_FDMode = PWM_FDMode_Latch;
000004  8001              STRH     r1,[r0,#0]
;;;381        PWM_FDInitStruct->PWM_FDVoltage = PWM_FDVoltage_Low;
000006  8041              STRH     r1,[r0,#2]
;;;382    }
000008  4770              BX       lr
;;;383    
                          ENDP


                          AREA ||i.PWM_FallingDeadTimeConfig||, CODE, READONLY, ALIGN=1

                  PWM_FallingDeadTimeConfig PROC
;;;149     */
;;;150    void PWM_FallingDeadTimeConfig ( PWM_TypeDef* PWMx, uint8_t PWM_FallingDeadTime )
000000  6902              LDR      r2,[r0,#0x10]
;;;151    {
;;;152        uint32_t tmpreg;
;;;153        /* Check the parameters */
;;;154        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;155    
;;;156        /* Get the PWMx PWM_DFR value */
;;;157        tmpreg = PWMx->PWM_DFR;
;;;158    
;;;159        /* Clear PDF bits */
;;;160        tmpreg &= ( uint32_t ) ~ ( PWM_DFR_PDF );
000002  230f              MOVS     r3,#0xf
000004  021b              LSLS     r3,r3,#8
000006  439a              BICS     r2,r2,r3
;;;161    
;;;162        /* Set PDF bits to Rising Dead Time value */
;;;163        tmpreg |= ( uint32_t ) ( PWM_FallingDeadTime << PWM_DFR_PDF_Pos );
000008  0209              LSLS     r1,r1,#8
00000a  4311              ORRS     r1,r1,r2
;;;164    
;;;165        /* Write to PWMx PWM_DFR */
;;;166        PWMx->PWM_DFR = tmpreg;
00000c  6101              STR      r1,[r0,#0x10]
;;;167    }
00000e  4770              BX       lr
;;;168    
                          ENDP


                          AREA ||i.PWM_GetCycle||, CODE, READONLY, ALIGN=1

                  PWM_GetCycle PROC
;;;269     */
;;;270    uint16_t PWM_GetCycle ( PWM_TypeDef* PWMx )
000000  6980              LDR      r0,[r0,#0x18]
;;;271    {
;;;272        /* Check the parameters */
;;;273        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;274    
;;;275        /* Get the ReloadData Register value */
;;;276        return ( uint16_t ) PWMx->PWM_CYCLE;
000002  b280              UXTH     r0,r0
;;;277    }
000004  4770              BX       lr
;;;278    
                          ENDP


                          AREA ||i.PWM_GetDuty||, CODE, READONLY, ALIGN=1

                  PWM_GetDuty PROC
;;;332     */
;;;333    uint16_t PWM_GetDuty ( PWM_TypeDef* PWMx, PWM_Channel_Typedef PWM_Channel )
000000  b510              PUSH     {r4,lr}
;;;334    {
;;;335        uint8_t tmpvalue ;
;;;336        uint32_t tmpchannel;
;;;337        /* Check the parameters */
;;;338        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;339        assert_param ( IS_PWM_CHANNEL ( PWM_Channel ) );
;;;340    
;;;341        tmpchannel = 1;
000002  2301              MOVS     r3,#1
000004  460c              MOV      r4,r1                 ;334
;;;342        for ( tmpvalue = 0; tmpvalue < 8; tmpvalue++ )
000006  2200              MOVS     r2,#0
                  |L9.8|
;;;343        {
;;;344            if ( ( uint32_t ) PWM_Channel & tmpchannel )
000008  421c              TST      r4,r3
00000a  d004              BEQ      |L9.22|
;;;345            {
;;;346                return ( uint16_t ) ( PWMx->PWM_DT[tmpvalue] );
00000c  0091              LSLS     r1,r2,#2
00000e  1808              ADDS     r0,r1,r0
000010  6b00              LDR      r0,[r0,#0x30]
000012  b280              UXTH     r0,r0
;;;347            }
;;;348            tmpchannel = tmpchannel << 1;
;;;349        }
;;;350        return 0;
;;;351    }
000014  bd10              POP      {r4,pc}
                  |L9.22|
000016  1c52              ADDS     r2,r2,#1              ;348
000018  005b              LSLS     r3,r3,#1              ;348
00001a  b2d2              UXTB     r2,r2                 ;342
00001c  2a08              CMP      r2,#8                 ;342
00001e  d3f3              BCC      |L9.8|
000020  2000              MOVS     r0,#0                 ;350
000022  bd10              POP      {r4,pc}
;;;352    
                          ENDP


                          AREA ||i.PWM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  PWM_GetFlagStatus PROC
;;;480     */
;;;481    FlagStatus PWM_GetFlagStatus ( PWM_TypeDef* PWMx, uint16_t PWM_FLAG )
000000  4602              MOV      r2,r0
;;;482    {
;;;483        ITStatus bitstatus = RESET;
;;;484        /* Check the parameters */
;;;485        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;486        assert_param ( IS_PWM_FLAG ( PWM_FLAG ) );
;;;487    
;;;488        if ( ( PWMx->PWM_STS & PWM_FLAG ) != ( uint16_t ) RESET )
000002  6892              LDR      r2,[r2,#8]
000004  2000              MOVS     r0,#0                 ;483
000006  420a              TST      r2,r1
000008  d000              BEQ      |L10.12|
;;;489        {
;;;490            bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L10.12|
;;;491        }
;;;492        else
;;;493        {
;;;494            bitstatus = RESET;
;;;495        }
;;;496        return bitstatus;
;;;497    }
00000c  4770              BX       lr
;;;498    
                          ENDP


                          AREA ||i.PWM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  PWM_GetPrescaler PROC
;;;237     */
;;;238    PWM_Prescaler_TypeDef PWM_GetPrescaler ( PWM_TypeDef* PWMx )
000000  6800              LDR      r0,[r0,#0]
;;;239    {
;;;240        /* Check the parameters */
;;;241        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;242    
;;;243        /* Get the CKD value */
;;;244        return ( PWM_Prescaler_TypeDef ) ( PWMx->PWM_CON & PWM_CON_PWMCLK );
000002  0740              LSLS     r0,r0,#29
000004  0f40              LSRS     r0,r0,#29
;;;245    }
000006  4770              BX       lr
;;;246    
                          ENDP


                          AREA ||i.PWM_ITConfig||, CODE, READONLY, ALIGN=1

                  PWM_ITConfig PROC
;;;451     */
;;;452    void PWM_ITConfig ( PWM_TypeDef* PWMx, uint16_t PWM_IT, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;453    {
;;;454        /* Check the parameters */
;;;455        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;456        assert_param ( IS_PWM_IT ( PWM_IT ) );
;;;457        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;458    
;;;459        if ( NewState != DISABLE )
;;;460        {
;;;461            /* Enable the Interrupt sources */
;;;462            PWMx->PWM_CON |= PWM_IT;
;;;463        }
;;;464        else
;;;465        {
;;;466            /* Disable the Interrupt sources */
;;;467            PWMx->PWM_CON &= ( uint16_t ) ~PWM_IT;
000002  6802              LDR      r2,[r0,#0]
000004  d001              BEQ      |L12.10|
000006  430a              ORRS     r2,r2,r1              ;462
000008  e002              B        |L12.16|
                  |L12.10|
00000a  43c9              MVNS     r1,r1
00000c  b289              UXTH     r1,r1
00000e  400a              ANDS     r2,r2,r1
                  |L12.16|
000010  6002              STR      r2,[r0,#0]            ;462
;;;468        }
;;;469    }
000012  4770              BX       lr
;;;470    
                          ENDP


                          AREA ||i.PWM_Init||, CODE, READONLY, ALIGN=1

                  PWM_Init PROC
;;;84      */
;;;85     void PWM_Init ( PWM_TypeDef* PWMx, PWM_InitTypeDef* PWM_InitStruct )
000000  b510              PUSH     {r4,lr}
;;;86     {
;;;87         uint32_t tmpreg;
;;;88         /* Check the parameters */
;;;89         assert_param ( IS_PWM_COMPLEMENTARY_PERIPH ( PWMx ) );
;;;90     
;;;91         /*---------------------------- PWMx PWM_CON Configuration ------------------------*/
;;;92         /* Get the PWMx PWM_CON value */
;;;93         tmpreg = PWMx->PWM_CON;
000002  6802              LDR      r2,[r0,#0]
;;;94         /* Clear PWMCLK, PWMMD0 and PWMMD1 SPR bits */
;;;95         tmpreg &= ( uint32_t ) ~ ( PWM_CON_PWMCLK | PWM_CON_PWMMD0 | PWM_CON_PWMMD1 );
000004  2367              MOVS     r3,#0x67
000006  439a              BICS     r2,r2,r3
;;;96         /* Configure PWMx: Prescaler, AlignedMode and WorkMode */
;;;97         /* Set PWMCLK bits according to Prescaler value */
;;;98         /* Set PWMMD0 bit according to AlignedMode value */
;;;99         /* Set PWMMD1 bit according to WorkMode value */
;;;100        tmpreg |= ( uint32_t ) ( PWM_InitStruct->PWM_Prescaler | PWM_InitStruct->PWM_AlignedMode |
000008  880b              LDRH     r3,[r1,#0]
00000a  884c              LDRH     r4,[r1,#2]
00000c  4323              ORRS     r3,r3,r4
00000e  888c              LDRH     r4,[r1,#4]
000010  4314              ORRS     r4,r4,r2
000012  4323              ORRS     r3,r3,r4
;;;101                                 PWM_InitStruct->PWM_WorkMode );
;;;102    
;;;103        /* Write to PWMx PWM_CON */
;;;104        PWMx->PWM_CON = tmpreg;
000014  6003              STR      r3,[r0,#0]
;;;105    
;;;106        /* Write to PWMx PWM_CHN */
;;;107        PWMx->PWM_CHN = PWM_InitStruct->PWM_OutputChannel;
000016  688a              LDR      r2,[r1,#8]
000018  6042              STR      r2,[r0,#4]
;;;108    
;;;109        /* Write to PWMx PWM_INV */
;;;110        PWMx->PWM_INV = PWM_InitStruct->PWM_LowPolarityChannl;
00001a  68ca              LDR      r2,[r1,#0xc]
00001c  60c2              STR      r2,[r0,#0xc]
;;;111    
;;;112        /* Write to PWMx PWM_CYCLE */
;;;113        PWMx->PWM_CYCLE = PWM_InitStruct->PWM_Cycle;
00001e  88c9              LDRH     r1,[r1,#6]
000020  6181              STR      r1,[r0,#0x18]
;;;114    }
000022  bd10              POP      {r4,pc}
;;;115    
                          ENDP


                          AREA ||i.PWM_RisingDeadTimeConfig||, CODE, READONLY, ALIGN=1

                  PWM_RisingDeadTimeConfig PROC
;;;123     */
;;;124    void PWM_RisingDeadTimeConfig ( PWM_TypeDef* PWMx, uint8_t PWM_RisingDeadTime )
000000  6902              LDR      r2,[r0,#0x10]
;;;125    {
;;;126        uint32_t tmpreg;
;;;127        /* Check the parameters */
;;;128        assert_param ( IS_PWM_COMPLEMENTARY_PERIPH ( PWMx ) );
;;;129    
;;;130        /* Get the PWMx PWM_DFR value */
;;;131        tmpreg = PWMx->PWM_DFR;
;;;132    
;;;133        /* Clear PDR bits */
;;;134        tmpreg &= ( uint32_t ) ~ ( PWM_DFR_PDR );
000002  0912              LSRS     r2,r2,#4
000004  0112              LSLS     r2,r2,#4
;;;135    
;;;136        /* Set PDR bits to Rising Dead Time value */
;;;137        tmpreg |= ( uint32_t ) ( PWM_RisingDeadTime << PWM_DFR_PDR_Pos );
000006  430a              ORRS     r2,r2,r1
;;;138    
;;;139        /* Write to PWMx PWM_DFR */
;;;140        PWMx->PWM_DFR = tmpreg;
000008  6102              STR      r2,[r0,#0x10]
;;;141    }
00000a  4770              BX       lr
;;;142    
                          ENDP


                          AREA ||i.PWM_SetCycle||, CODE, READONLY, ALIGN=1

                  PWM_SetCycle PROC
;;;254     */
;;;255    void PWM_SetCycle ( PWM_TypeDef* PWMx, uint32_t PWM_Cycle )
000000  6181              STR      r1,[r0,#0x18]
;;;256    {
;;;257        /* Check the parameters */
;;;258        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;259    
;;;260        /* Set the ReloadData Register value */
;;;261        PWMx->PWM_CYCLE = PWM_Cycle;
;;;262    }
000002  4770              BX       lr
;;;263    
                          ENDP


                          AREA ||i.PWM_SetDuty||, CODE, READONLY, ALIGN=1

                  PWM_SetDuty PROC
;;;296     */
;;;297    void PWM_SetDuty ( PWM_TypeDef* PWMx, PWM_Channel_Typedef PWM_Channel, uint16_t PWM_Duty )
000000  b530              PUSH     {r4,r5,lr}
;;;298    {
;;;299        uint8_t tmpvalue;
;;;300        uint32_t tmpchannel;
;;;301        /* Check the parameters */
;;;302        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;303        assert_param ( IS_PWM_CHANNEL ( PWM_Channel ) );
;;;304    
;;;305        tmpchannel = 1;
000002  2401              MOVS     r4,#1
;;;306        for ( tmpvalue = 0; tmpvalue < 8; tmpvalue++ )
000004  2300              MOVS     r3,#0
                  |L16.6|
;;;307        {
;;;308            if ( ( uint32_t ) PWM_Channel & tmpchannel )
000006  4221              TST      r1,r4
000008  d002              BEQ      |L16.16|
;;;309            {
;;;310                PWMx->PWM_DT[tmpvalue] = PWM_Duty;
00000a  009d              LSLS     r5,r3,#2
00000c  182d              ADDS     r5,r5,r0
00000e  632a              STR      r2,[r5,#0x30]
                  |L16.16|
;;;311            }
;;;312            tmpchannel = tmpchannel << 1;
000010  1c5b              ADDS     r3,r3,#1
000012  0064              LSLS     r4,r4,#1
000014  b2db              UXTB     r3,r3                 ;306
000016  2b08              CMP      r3,#8                 ;306
000018  d3f5              BCC      |L16.6|
;;;313        }
;;;314    }
00001a  bd30              POP      {r4,r5,pc}
;;;315    
                          ENDP


                          AREA ||i.PWM_SetPrescaler||, CODE, READONLY, ALIGN=2

                  PWM_SetPrescaler PROC
;;;210     */
;;;211    void PWM_SetPrescaler ( PWM_TypeDef* PWMx, PWM_Prescaler_TypeDef PWM_Prescaler )
000000  6802              LDR      r2,[r0,#0]
;;;212    {
;;;213        /* Check the parameters */
;;;214        assert_param ( IS_PWM_ALL_PERIPH ( PWMx ) );
;;;215        assert_param ( IS_PWM_PRESCALER ( PWM_Prescaler ) );
;;;216    
;;;217        /* Reset the CKD Bits */
;;;218        PWMx->PWM_CON &= ( uint16_t ) ~ ( PWM_CON_PWMCLK );
000002  4b03              LDR      r3,|L17.16|
000004  401a              ANDS     r2,r2,r3
000006  6002              STR      r2,[r0,#0]
;;;219    
;;;220        /* Set the CKD value */
;;;221        PWMx->PWM_CON |= PWM_Prescaler;
000008  6802              LDR      r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  6002              STR      r2,[r0,#0]
;;;222    }
00000e  4770              BX       lr
;;;223    
                          ENDP

                  |L17.16|
                          DCD      0x0000fff8

                          AREA ||i.PWM_StructInit||, CODE, READONLY, ALIGN=1

                  PWM_StructInit PROC
;;;65       */
;;;66     void PWM_StructInit ( PWM_InitTypeDef* PWM_InitStruct )
000000  2100              MOVS     r1,#0
;;;67     {
;;;68         /* Set the default configuration */
;;;69         PWM_InitStruct->PWM_AlignedMode = PWM_AlignmentMode_Edge;
000002  8041              STRH     r1,[r0,#2]
;;;70         PWM_InitStruct->PWM_Cycle = 0x0000;
000004  80c1              STRH     r1,[r0,#6]
;;;71         PWM_InitStruct->PWM_LowPolarityChannl = PWMChannel_Less;
;;;72         PWM_InitStruct->PWM_OutputChannel = PWMChannel_Less;
000006  60c1              STR      r1,[r0,#0xc]
;;;73         PWM_InitStruct->PWM_Prescaler = PWM_PRESCALER_DIV1;
000008  6081              STR      r1,[r0,#8]
00000a  8001              STRH     r1,[r0,#0]
;;;74         PWM_InitStruct->PWM_WorkMode = PWM_WorkMode_Independent;
00000c  8081              STRH     r1,[r0,#4]
;;;75     }
00000e  4770              BX       lr
;;;76     
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_pwm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_pwm_c_a9b1a8f2____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_pwm_c_a9b1a8f2____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_pwm_c_a9b1a8f2____REVSH|
#line 478
|__asm___15_sc32f1xxx_pwm_c_a9b1a8f2____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
