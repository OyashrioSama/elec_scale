; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: armcc [4d365d]
; commandline armcc [--c99 --list --split_sections --debug -c --asm --interleave -o..\Output\sc32f1xxx_spi.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\Output\sc32f1xxx_spi.d --cpu=Cortex-M0+ --apcs=interwork --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -D__UVISION_VERSION=536 -DSC32f12xx --omf_browse=..\Output\sc32f1xxx_spi.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_spi.c]
                          THUMB

                          AREA ||i.SPI_ClearFlag||, CODE, READONLY, ALIGN=1

                  SPI_ClearFlag PROC
;;;565     */
;;;566    void SPI_ClearFlag ( SPI_TypeDef* SPIx, uint32_t SPI_FLAG )
000000  b289              UXTH     r1,r1
;;;567    {
;;;568    #if defined(SC32f10xx)||defined(SC32f12xx)
;;;569        /* Check the parameters */
;;;570        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;571        /* Clear the flags */
;;;572        SPIx->SPI_STS = ( uint16_t ) SPI_FLAG;
000002  6041              STR      r1,[r0,#4]
;;;573    
;;;574    #endif
;;;575    }
000004  4770              BX       lr
;;;576    
                          ENDP


                          AREA ||i.SPI_Cmd||, CODE, READONLY, ALIGN=2

                  SPI_Cmd PROC
;;;165     */
;;;166    void SPI_Cmd ( SPI_TypeDef* SPIx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;167    {
;;;168    #if defined(SC32f10xx)||defined(SC32f12xx)
;;;169        /* Check the parameters */
;;;170        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;171        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;172        if ( NewState != DISABLE )
;;;173        {
;;;174            /* Enable the SPI TX Function */
;;;175            SPIx->SPI_CON |= SPI_CON_SPEN;
;;;176        }
;;;177        else
;;;178        {
;;;179            /* Disable the SPI TX Function */
;;;180            SPIx->SPI_CON &= ( uint16_t ) ~SPI_CON_SPEN;
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L2.12|
000006  2280              MOVS     r2,#0x80              ;175
000008  4311              ORRS     r1,r1,r2              ;175
00000a  e001              B        |L2.16|
                  |L2.12|
00000c  4a01              LDR      r2,|L2.20|
00000e  4011              ANDS     r1,r1,r2
                  |L2.16|
000010  6001              STR      r1,[r0,#0]            ;175
;;;181        }
;;;182    
;;;183    #endif
;;;184    }
000012  4770              BX       lr
;;;185    
                          ENDP

                  |L2.20|
                          DCD      0x0000ff7f

                          AREA ||i.SPI_DMACmd||, CODE, READONLY, ALIGN=1

                  SPI_DMACmd PROC
;;;593     */
;;;594    void SPI_DMACmd ( SPI_TypeDef* SPIx, uint16_t SPI_DMAReq, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;595    {
;;;596        /* Check the parameters */
;;;597        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;598        assert_param ( IS_SPI_DMAREQ ( SPI_DMAReq ) );
;;;599        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;600        if ( NewState != DISABLE )
;;;601        {
;;;602            /* Enable the selected SPI DMA requests */
;;;603            SPIx->SPI_IDE |= SPI_DMAReq;
;;;604        }
;;;605        else
;;;606        {
;;;607            /* Disable the selected SPI DMA requests */
;;;608            SPIx->SPI_IDE &= ( uint16_t ) ~SPI_DMAReq;
000002  6902              LDR      r2,[r0,#0x10]
000004  d001              BEQ      |L3.10|
000006  430a              ORRS     r2,r2,r1              ;603
000008  e002              B        |L3.16|
                  |L3.10|
00000a  43c9              MVNS     r1,r1
00000c  b289              UXTH     r1,r1
00000e  400a              ANDS     r2,r2,r1
                  |L3.16|
000010  6102              STR      r2,[r0,#0x10]         ;603
;;;609        }
;;;610    }
000012  4770              BX       lr
;;;611    
                          ENDP


                          AREA ||i.SPI_DataSizeConfig||, CODE, READONLY, ALIGN=2

                  SPI_DataSizeConfig PROC
;;;235      */
;;;236    void SPI_DataSizeConfig ( SPI_TypeDef* SPIx, SPI_DataSize_TypeDef SPI_DataSize )
000000  6802              LDR      r2,[r0,#0]
;;;237    {
;;;238    #if defined(SC32f10xx)||defined(SC32f12xx)
;;;239        /* Check the parameters */
;;;240        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;241        assert_param ( IS_SPI_DATASIZE ( SPI_DataSize ) );
;;;242    
;;;243        /* Clear SPMD bit */
;;;244        SPIx->SPI_CON &= ( uint16_t ) ~SPI_CON_SPMD;
000002  4b03              LDR      r3,|L4.16|
000004  401a              ANDS     r2,r2,r3
000006  6002              STR      r2,[r0,#0]
;;;245        /* Set new SPMD bit value */
;;;246        SPIx->SPI_CON |= SPI_DataSize;
000008  6802              LDR      r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  6002              STR      r2,[r0,#0]
;;;247    
;;;248    #endif
;;;249    }
00000e  4770              BX       lr
;;;250    
                          ENDP

                  |L4.16|
                          DCD      0x0000fffd

                          AREA ||i.SPI_DeInit||, CODE, READONLY, ALIGN=2

                  SPI_DeInit PROC
;;;50      */
;;;51     void SPI_DeInit ( SPI_TypeDef* SPIx )
000000  b570              PUSH     {r4-r6,lr}
;;;52     {
000002  4604              MOV      r4,r0
;;;53         /* Check the parameters */
;;;54         assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;55         if ( SPIx == SPI0 )
000004  480e              LDR      r0,|L5.64|
000006  2500              MOVS     r5,#0
;;;56         {
;;;57     #if defined(SC32f10xx)||defined(SC32f12xx)
;;;58             /* Enable SPI0 reset state */
;;;59             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_SPI0, ENABLE );
;;;60             /* Release SPI0 from reset state */
;;;61             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_SPI0, DISABLE );		
;;;62     #endif
;;;63         }
;;;64         else if ( SPIx == SPI1 )
;;;65         {
;;;66     #if defined(SC32f10xx)||defined(SC32f12xx)
;;;67             /* Clear SPI1 Register */
;;;68             SPIx->SPI_CON  = ( uint16_t ) 0x00000000;
;;;69             SPIx->SPI_DATA = ( uint16_t ) 0x00000000;
;;;70             SPIx->SPI_IDE  = ( uint16_t ) 0x00000000;
;;;71             SPIx->SPI_STS  = ( uint16_t ) 0x000000FF;
000008  26ff              MOVS     r6,#0xff
00000a  4284              CMP      r4,r0                 ;55
00000c  d108              BNE      |L5.32|
00000e  2101              MOVS     r1,#1                 ;59
000010  2020              MOVS     r0,#0x20              ;59
000012  f7fffffe          BL       RCC_APB0PeriphResetCmd
000016  2100              MOVS     r1,#0                 ;61
000018  2020              MOVS     r0,#0x20              ;61
00001a  f7fffffe          BL       RCC_APB0PeriphResetCmd
00001e  e006              B        |L5.46|
                  |L5.32|
000020  4808              LDR      r0,|L5.68|
000022  4284              CMP      r4,r0                 ;64
000024  d103              BNE      |L5.46|
000026  6025              STR      r5,[r4,#0]            ;68
000028  60e5              STR      r5,[r4,#0xc]          ;69
00002a  6125              STR      r5,[r4,#0x10]         ;70
00002c  6066              STR      r6,[r4,#4]
                  |L5.46|
;;;72     
;;;73     #endif
;;;74         }
;;;75     #if defined(SC32f12xx)
;;;76         if ( SPIx == SPI2 )
00002e  4805              LDR      r0,|L5.68|
000030  3060              ADDS     r0,r0,#0x60
000032  4284              CMP      r4,r0
000034  d103              BNE      |L5.62|
;;;77         {
;;;78             /* Clear SPI1 Register */
;;;79             SPIx->SPI_CON  = ( uint16_t ) 0x00000000;
000036  6025              STR      r5,[r4,#0]
;;;80             SPIx->SPI_DATA = ( uint16_t ) 0x00000000;
000038  60e5              STR      r5,[r4,#0xc]
;;;81             SPIx->SPI_IDE  = ( uint16_t ) 0x00000000;
00003a  6125              STR      r5,[r4,#0x10]
;;;82             SPIx->SPI_STS  = ( uint16_t ) 0x000000FF;
00003c  6066              STR      r6,[r4,#4]
                  |L5.62|
;;;83         }		
;;;84     #endif
;;;85     
;;;86     }
00003e  bd70              POP      {r4-r6,pc}
;;;87     
                          ENDP

                  |L5.64|
                          DCD      0x40020040
                  |L5.68|
                          DCD      0x40021040

                          AREA ||i.SPI_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  SPI_GetFlagStatus PROC
;;;525     */
;;;526    FlagStatus SPI_GetFlagStatus ( SPI_TypeDef* SPIx, SPI_FLAG_TypeDef SPI_FLAG )
000000  4602              MOV      r2,r0
;;;527    {
;;;528    #if defined(SC32f10xx)||defined(SC32f12xx)
;;;529        ITStatus bitstatus = RESET;
;;;530        /* Check the parameters */
;;;531        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;532        assert_param ( IS_SPI_FLAG ( SPI_FLAG ) );
;;;533    
;;;534        if ( ( SPIx->SPI_STS & SPI_FLAG ) != ( uint16_t ) RESET )
000002  6852              LDR      r2,[r2,#4]
000004  2000              MOVS     r0,#0                 ;529
000006  420a              TST      r2,r1
000008  d000              BEQ      |L6.12|
;;;535        {
;;;536            bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L6.12|
;;;537        }
;;;538        else
;;;539        {
;;;540            bitstatus = RESET;
;;;541        }
;;;542        return bitstatus;
;;;543    
;;;544    #endif
;;;545    }
00000c  4770              BX       lr
;;;546    
                          ENDP


                          AREA ||i.SPI_ITConfig||, CODE, READONLY, ALIGN=1

                  SPI_ITConfig PROC
;;;483     */
;;;484    void SPI_ITConfig ( SPI_TypeDef* SPIx, uint16_t SPI_IT, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;485    {
;;;486    
;;;487        /* Check the parameters */
;;;488        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;489        assert_param ( IS_SPI_IT ( SPI_IT ) );
;;;490        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;491        if ( NewState != DISABLE )
;;;492        {
;;;493            /* Enable the Interrupt sources */
;;;494            SPIx->SPI_IDE |= SPI_IT;
;;;495        }
;;;496        else
;;;497        {
;;;498            /* Disable the Interrupt sources */
;;;499            SPIx->SPI_IDE &= ( uint16_t ) ~SPI_IT;
000002  6902              LDR      r2,[r0,#0x10]
000004  d001              BEQ      |L7.10|
000006  430a              ORRS     r2,r2,r1              ;494
000008  e002              B        |L7.16|
                  |L7.10|
00000a  43c9              MVNS     r1,r1
00000c  b289              UXTH     r1,r1
00000e  400a              ANDS     r2,r2,r1
                  |L7.16|
000010  6102              STR      r2,[r0,#0x10]         ;494
;;;500        }
;;;501    
;;;502    }
000012  4770              BX       lr
;;;503    
                          ENDP


                          AREA ||i.SPI_Init||, CODE, READONLY, ALIGN=2

                  SPI_Init PROC
;;;115     */
;;;116    void SPI_Init ( SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct )
000000  b530              PUSH     {r4,r5,lr}
;;;117    {
;;;118    #if defined(SC32f10xx)||defined(SC32f12xx)
;;;119        uint32_t tmpreg;
;;;120        /* Check the parameters */
;;;121        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;122        assert_param ( IS_SPI_Mode ( SPI_InitStruct->SPI_Mode ) );
;;;123        assert_param ( IS_SPI_DATASIZE ( SPI_InitStruct->SPI_DataSize ) );
;;;124        assert_param ( IS_SPI_CPHA ( SPI_InitStruct->SPI_CPHA ) );
;;;125        assert_param ( IS_SPI_CPOL ( SPI_InitStruct->SPI_CPOL ) );
;;;126        assert_param ( IS_SPI_PRESCALER ( SPI_InitStruct->SPI_Prescaler ) );
;;;127        assert_param ( IS_SPI_FIRSTBIT ( SPI_InitStruct->SPI_FirstBit ) );
;;;128    
;;;129        /*---------------------------- SPIx SPI_CON Configuration ------------------------*/
;;;130        /* Get the SPIx SPI_CON value */
;;;131        tmpreg = SPIx->SPI_CON;
000002  6802              LDR      r2,[r0,#0]
;;;132        /* Clear MSTR, SPMD, DORD, CPOL, SPR bits */
;;;133        tmpreg &= ( uint32_t ) ~ ( SPI_CON_MSTR | SPI_CON_SPMD | SPI_CON_DORD |
000004  4b07              LDR      r3,|L8.36|
000006  401a              ANDS     r2,r2,r3
000008  c918              LDM      r1!,{r3,r4}
;;;134                                   SPI_CON_CPHA | SPI_CON_CPOL | SPI_CON_SPR );
;;;135        /* Configure SPIx: mode, data size, first transmitted bit,clock predivision , CPOL and CPHA */
;;;136        /* Set MSTR bits to SPI_Mode value */
;;;137        /* Set SPMD bit according to SPI_DataSize value */
;;;138        /* Set DORD bit according to SPI_FirstBit value */
;;;139        /* Set CPOL bit according to SPI_CPOL value */
;;;140        /* Set CPHA bit according to SPI_CPHA value */
;;;141        /* Set SPR according to SPI_Prescaler value */
;;;142        tmpreg |= ( uint32_t ) ( SPI_InitStruct->SPI_Mode | SPI_InitStruct->SPI_DataSize |
00000a  680d              LDR      r5,[r1,#0]
00000c  4323              ORRS     r3,r3,r4
00000e  688c              LDR      r4,[r1,#8]
000010  432c              ORRS     r4,r4,r5
000012  4323              ORRS     r3,r3,r4
000014  684c              LDR      r4,[r1,#4]
000016  68c9              LDR      r1,[r1,#0xc]
000018  4323              ORRS     r3,r3,r4
00001a  430b              ORRS     r3,r3,r1
00001c  4313              ORRS     r3,r3,r2
;;;143                                 SPI_InitStruct->SPI_FirstBit | SPI_InitStruct->SPI_CPHA |
;;;144                                 SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_Prescaler );
;;;145        /* Write to SPIx SPI_CON */
;;;146        SPIx->SPI_CON = tmpreg;
00001e  6003              STR      r3,[r0,#0]
;;;147    
;;;148    		
;;;149    #endif
;;;150    }
000020  bd30              POP      {r4,r5,pc}
;;;151    
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      0xfffff0e0

                          AREA ||i.SPI_PinRemapConfig||, CODE, READONLY, ALIGN=1

                  SPI_PinRemapConfig PROC
;;;418     */
;;;419    void SPI_PinRemapConfig ( SPI_TypeDef* SPIx, SPI_PinRemap_TypeDef SPI_PinRemap )
000000  6802              LDR      r2,[r0,#0]
;;;420    {
;;;421    #if defined(SC32f10xx)||defined(SC32f12xx)
;;;422        uint32_t tmpreg ;
;;;423        /* Check the parameters */
;;;424        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;425        if ( SPIx == SPI0 )
;;;426        {
;;;427            assert_param ( IS_SPI_LIST1_PINREMAP ( SPI_PinRemap ) );
;;;428        }
;;;429        else
;;;430        {
;;;431            assert_param ( IS_SPI_LIST2_PINREMAP ( SPI_PinRemap ) );
;;;432        }
;;;433    
;;;434        tmpreg = SPIx->SPI_CON;
;;;435    
;;;436        tmpreg &= ( uint32_t ) ( ~SPI_CON_SPOS );
000002  2303              MOVS     r3,#3
000004  039b              LSLS     r3,r3,#14
000006  439a              BICS     r2,r2,r3
;;;437    
;;;438        tmpreg |= SPI_PinRemap;
000008  430a              ORRS     r2,r2,r1
;;;439    
;;;440        SPIx->SPI_CON = tmpreg;
00000a  6002              STR      r2,[r0,#0]
;;;441    
;;;442    
;;;443    
;;;444    #endif
;;;445    }
00000c  4770              BX       lr
;;;446    
                          ENDP


                          AREA ||i.SPI_ReceiveData||, CODE, READONLY, ALIGN=1

                  SPI_ReceiveData PROC
;;;377     */
;;;378    uint32_t SPI_ReceiveData ( SPI_TypeDef* SPIx )
000000  68c0              LDR      r0,[r0,#0xc]
;;;379    {
;;;380        /* Check the parameters */
;;;381        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;382        return ( uint32_t ) SPIx->SPI_DATA;
;;;383    }
000002  4770              BX       lr
;;;384    
                          ENDP


                          AREA ||i.SPI_ReceiveDataFIFO||, CODE, READONLY, ALIGN=1

                  SPI_ReceiveDataFIFO PROC
;;;318     */
;;;319    void SPI_ReceiveDataFIFO ( SPI_TypeDef* SPIx, uint32_t* Data, uint16_t length )
000000  b530              PUSH     {r4,r5,lr}
;;;320    {
;;;321    #if defined(SC32f10xx)||defined(SC32f12xx)
;;;322        uint16_t tmpNum;
;;;323        /* Check the parameters */
;;;324        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;325        /* ReceiveData 16Bit Data */
;;;326        if ( SPIx->SPI_CON & SPI_CON_SPMD )
000002  6803              LDR      r3,[r0,#0]
000004  079b              LSLS     r3,r3,#30
000006  d509              BPL      |L11.28|
;;;327        {
;;;328            for ( tmpNum = 0; tmpNum < length; tmpNum++ )
000008  2300              MOVS     r3,#0
00000a  e004              B        |L11.22|
                  |L11.12|
;;;329            {
;;;330               ( * ( ( uint16_t* ) Data + tmpNum ) ) = ( uint16_t ) SPIx->SPI_DATA;
00000c  68c4              LDR      r4,[r0,#0xc]
00000e  005d              LSLS     r5,r3,#1
000010  1c5b              ADDS     r3,r3,#1
000012  534c              STRH     r4,[r1,r5]
000014  b29b              UXTH     r3,r3                 ;328
                  |L11.22|
000016  4293              CMP      r3,r2                 ;328
000018  d3f8              BCC      |L11.12|
;;;331            }
;;;332        }
;;;333        /* Transmit 8 Bit Data */
;;;334        else
;;;335        {
;;;336            for ( tmpNum = 0; tmpNum < length; tmpNum++ )
;;;337            {
;;;338                ( * ( ( uint8_t* ) Data + tmpNum ) ) = ( uint8_t ) SPIx->SPI_DATA;
;;;339            }
;;;340        }
;;;341    
;;;342    #endif
;;;343    }
00001a  bd30              POP      {r4,r5,pc}
                  |L11.28|
00001c  2300              MOVS     r3,#0                 ;336
00001e  e003              B        |L11.40|
                  |L11.32|
000020  68c4              LDR      r4,[r0,#0xc]          ;338
000022  54cc              STRB     r4,[r1,r3]            ;338
000024  1c5b              ADDS     r3,r3,#1              ;338
000026  b29b              UXTH     r3,r3                 ;336
                  |L11.40|
000028  4293              CMP      r3,r2                 ;336
00002a  d3f9              BCC      |L11.32|
00002c  bd30              POP      {r4,r5,pc}
;;;344    
                          ENDP


                          AREA ||i.SPI_SendData||, CODE, READONLY, ALIGN=1

                  SPI_SendData PROC
;;;356     */
;;;357    void SPI_SendData ( SPI_TypeDef* SPIx, uint32_t Data )
000000  60c1              STR      r1,[r0,#0xc]
;;;358    {
;;;359    
;;;360        /* Check the parameters */
;;;361        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;362        /* Transmit  Data */
;;;363        SPIx->SPI_DATA = Data;
;;;364    
;;;365    }
000002  4770              BX       lr
;;;366    
                          ENDP


                          AREA ||i.SPI_SendDataFIFO||, CODE, READONLY, ALIGN=1

                  SPI_SendDataFIFO PROC
;;;279     */
;;;280    void SPI_SendDataFIFO ( SPI_TypeDef* SPIx, uint32_t* Data, uint16_t length )
000000  b510              PUSH     {r4,lr}
;;;281    {
;;;282    #if defined(SC32f10xx)||defined(SC32f12xx)
;;;283        uint8_t tmpNum;
;;;284        /* Check the parameters */
;;;285        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;286        /* Transmit 16Bit Data */
;;;287        if ( SPIx->SPI_CON & SPI_CON_SPMD )
000002  6803              LDR      r3,[r0,#0]
000004  079b              LSLS     r3,r3,#30
000006  d509              BPL      |L13.28|
;;;288        {
;;;289            for ( tmpNum = 0; tmpNum < length; tmpNum++ )
000008  2300              MOVS     r3,#0
00000a  e004              B        |L13.22|
                  |L13.12|
;;;290            {
;;;291                SPIx->SPI_DATA = ( uint16_t )( * ( ( uint16_t* ) Data + tmpNum ) );
00000c  005c              LSLS     r4,r3,#1
00000e  5b0c              LDRH     r4,[r1,r4]
000010  60c4              STR      r4,[r0,#0xc]
000012  1c5b              ADDS     r3,r3,#1
000014  b2db              UXTB     r3,r3                 ;289
                  |L13.22|
000016  4293              CMP      r3,r2                 ;289
000018  d3f8              BCC      |L13.12|
;;;292            }
;;;293        }
;;;294        /* Transmit 8 Bit Data */
;;;295        else
;;;296        {
;;;297            for ( tmpNum = 0; tmpNum < length; tmpNum++ )
;;;298            {
;;;299                SPIx->SPI_DATA = ( uint16_t ) ( * ( ( uint8_t* ) Data + tmpNum ) );
;;;300            }
;;;301        }
;;;302    
;;;303    #endif
;;;304    }
00001a  bd10              POP      {r4,pc}
                  |L13.28|
00001c  2300              MOVS     r3,#0                 ;297
00001e  e003              B        |L13.40|
                  |L13.32|
000020  5ccc              LDRB     r4,[r1,r3]            ;299
000022  60c4              STR      r4,[r0,#0xc]          ;299
000024  1c5b              ADDS     r3,r3,#1              ;299
000026  b2db              UXTB     r3,r3                 ;297
                  |L13.40|
000028  4293              CMP      r3,r2                 ;297
00002a  d3f9              BCC      |L13.32|
00002c  bd10              POP      {r4,pc}
;;;305    
                          ENDP


                          AREA ||i.SPI_SetMode||, CODE, READONLY, ALIGN=1

                  SPI_SetMode PROC
;;;199     */
;;;200    void SPI_SetMode ( SPI_TypeDef* SPIx, SPI_Mode_TypeDef SPI_Mode )
000000  6802              LDR      r2,[r0,#0]
;;;201    {
;;;202    #if defined(SC32f10xx)||defined(SC32f12xx)
;;;203        uint32_t tmpreg;
;;;204        /* Check the parameters */
;;;205        assert_param ( IS_SPI_ALL_PERIPH ( SPIx ) );
;;;206    
;;;207        tmpreg = SPIx->SPI_CON;
;;;208        /* Clear MSTR bit */
;;;209        tmpreg &= ( uint32_t ) ~SPI_CON_MSTR;
000002  0852              LSRS     r2,r2,#1
000004  0052              LSLS     r2,r2,#1
;;;210        /* Cogfig MSTR bit */
;;;211        tmpreg |= ( uint32_t ) SPI_Mode;
000006  430a              ORRS     r2,r2,r1
;;;212        /* Set new MSTR bit value */
;;;213        SPIx->SPI_CON |= tmpreg;
000008  6801              LDR      r1,[r0,#0]
00000a  4311              ORRS     r1,r1,r2
00000c  6001              STR      r1,[r0,#0]
;;;214    
;;;215    #endif
;;;216    }
00000e  4770              BX       lr
;;;217    
                          ENDP


                          AREA ||i.SPI_StructInit||, CODE, READONLY, ALIGN=1

                  SPI_StructInit PROC
;;;92       */
;;;93     void SPI_StructInit ( SPI_InitTypeDef* SPI_InitStruct )
000000  2100              MOVS     r1,#0
;;;94     {
;;;95         /* Set the default configuration */
;;;96         SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
;;;97         SPI_InitStruct->SPI_DataSize = SPI_DataSize_8B;
000002  6001              STR      r1,[r0,#0]
;;;98         SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_LSB;
;;;99         SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
000004  6041              STR      r1,[r0,#4]
;;;100        SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
000006  6081              STR      r1,[r0,#8]
000008  2204              MOVS     r2,#4                 ;98
;;;101        SPI_InitStruct->SPI_Prescaler = SPI_Prescaler_1;
00000a  60c1              STR      r1,[r0,#0xc]
00000c  6102              STR      r2,[r0,#0x10]
00000e  6141              STR      r1,[r0,#0x14]
;;;102    }
000010  4770              BX       lr
;;;103    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_spi_c_a2ad70c2____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___15_sc32f1xxx_spi_c_a2ad70c2____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_sc32f1xxx_spi_c_a2ad70c2____REVSH|
#line 478
|__asm___15_sc32f1xxx_spi_c_a2ad70c2____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
