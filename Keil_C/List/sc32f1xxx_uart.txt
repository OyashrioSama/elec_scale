; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: armcc [4d365d]
; commandline armcc [--c99 --list --split_sections --debug -c --asm --interleave -o..\Output\sc32f1xxx_uart.o --asm_dir=..\List\ --list_dir=..\List\ --depend=..\Output\sc32f1xxx_uart.d --cpu=Cortex-M0+ --apcs=interwork --diag_suppress=9931 -I..\FWLib\SC32F1XXX_Lib\inc -I..\User\HeadFiles -I..\User -I..\Drivers -I..\Apps -I..\CMSIS -D__UVISION_VERSION=536 -DSC32f12xx --omf_browse=..\Output\sc32f1xxx_uart.crf ..\FWLib\SC32F1XXX_Lib\src\sc32f1xxx_uart.c]
                          THUMB

                          AREA ||i.LINCalChecksum||, CODE, READONLY, ALIGN=1

                  LINCalChecksum PROC
;;;739     */
;;;740    uint8_t LINCalChecksum ( uint8_t id, uint8_t *data, uint8_t len )
000000  b530              PUSH     {r4,r5,lr}
;;;741    {
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
;;;742        uint32_t sum = LIN_CalID ( id );
000006  f7fffffe          BL       LIN_CalID
;;;743        uint8_t i;
;;;744    
;;;745        for ( i = 0; i < len; i++ )
00000a  2300              MOVS     r3,#0
00000c  e008              B        |L1.32|
                  |L1.14|
;;;746        {
;;;747            sum += data[i];
00000e  5ce9              LDRB     r1,[r5,r3]
000010  1808              ADDS     r0,r1,r0
;;;748            if ( sum & 0xFF00 )
000012  0401              LSLS     r1,r0,#16
000014  0e09              LSRS     r1,r1,#24
000016  d001              BEQ      |L1.28|
;;;749            {
;;;750                sum = ( sum & 0x00FF ) + 1;
000018  b2c0              UXTB     r0,r0
00001a  1c40              ADDS     r0,r0,#1
                  |L1.28|
00001c  1c5b              ADDS     r3,r3,#1
00001e  b2db              UXTB     r3,r3                 ;745
                  |L1.32|
000020  42a3              CMP      r3,r4                 ;745
000022  d3f4              BCC      |L1.14|
;;;751            }
;;;752        }
;;;753    
;;;754        sum ^= 0x00FF;
000024  21ff              MOVS     r1,#0xff
000026  4048              EORS     r0,r0,r1
;;;755        return ( uint8_t ) sum;
000028  b2c0              UXTB     r0,r0
;;;756    }
00002a  bd30              POP      {r4,r5,pc}
;;;757    #endif
                          ENDP


                          AREA ||i.LIN_CalID||, CODE, READONLY, ALIGN=1

                  LIN_CalID PROC
;;;720     */
;;;721    uint8_t LIN_CalID ( uint8_t id )
000000  0841              LSRS     r1,r0,#1
;;;722    {
;;;723        uint8_t parity, p0, p1;
;;;724    
;;;725        parity = id;
;;;726        p0 = ( BIT ( parity, 0 ) ^ BIT ( parity, 1 ) ^ BIT ( parity, 2 ) ^ BIT ( parity, 4 ) ) << 6;
000002  460a              MOV      r2,r1
000004  4042              EORS     r2,r2,r0
000006  07d3              LSLS     r3,r2,#31
000008  0742              LSLS     r2,r0,#29
00000a  b510              PUSH     {r4,lr}               ;722
00000c  0fdb              LSRS     r3,r3,#31
00000e  0fd2              LSRS     r2,r2,#31
000010  4053              EORS     r3,r3,r2
000012  06c2              LSLS     r2,r0,#27
;;;727        p1 = ( ! ( BIT ( parity, 1 ) ^ BIT ( parity, 3 ) ^ BIT ( parity, 4 ) ^ BIT ( parity, 5 ) ) ) << 7;
000014  08c4              LSRS     r4,r0,#3
000016  0fd2              LSRS     r2,r2,#31             ;726
000018  4061              EORS     r1,r1,r4
00001a  07c9              LSLS     r1,r1,#31
00001c  4053              EORS     r3,r3,r2              ;726
00001e  0fc9              LSRS     r1,r1,#31
000020  4051              EORS     r1,r1,r2
000022  0682              LSLS     r2,r0,#26
000024  0fd2              LSRS     r2,r2,#31
000026  4051              EORS     r1,r1,r2
000028  2201              MOVS     r2,#1
00002a  019b              LSLS     r3,r3,#6              ;726
00002c  4051              EORS     r1,r1,r2
00002e  01c9              LSLS     r1,r1,#7
;;;728    
;;;729        parity |= ( p0 | p1 );
000030  430b              ORRS     r3,r3,r1
000032  4318              ORRS     r0,r0,r3
;;;730    
;;;731        return parity;
;;;732    }
000034  bd10              POP      {r4,pc}
;;;733    /**
                          ENDP


                          AREA ||i.Printf_UartInit||, CODE, READONLY, ALIGN=2

                  Printf_UartInit PROC
;;;788     */
;;;789    __attribute__((weak)) void Printf_UartInit ( UART_TypeDef* UARTx )
000000  4901              LDR      r1,|L3.8|
;;;790    {
;;;791    
;;;792        Printf_Uart = UARTx;
000002  6008              STR      r0,[r1,#0]  ; Printf_Uart
;;;793    }
000004  4770              BX       lr
;;;794    /*printf mapping function*/
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      ||.data||

                          AREA ||i.UART_ClearFlag||, CODE, READONLY, ALIGN=1

                  UART_ClearFlag PROC
;;;513     */
;;;514    void UART_ClearFlag ( UART_TypeDef* UARTx, uint16_t UART_FLAG )
000000  6041              STR      r1,[r0,#4]
;;;515    {
;;;516        /* Check the parameters */
;;;517        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;518    
;;;519        /* Clear the flags */
;;;520        UARTx->UART_STS = ( uint16_t ) UART_FLAG;
;;;521    	
;;;522    #if (UARTOptSwitch)
;;;523    #if defined(SC32f10xx)
;;;524    		if(UARTx == UART0)
;;;525    		{
;;;526    				/* Restore the UART RX status */
;;;527            UARTx->UART_CON |= RXStatus;
;;;528    		}
;;;529    #elif defined(SC32f12xx)
;;;530    		if((UARTx == UART1) && ((UART1->UART_CON & UART_CON_SPOS) == 0))
;;;531    		{
;;;532    				/* Restore the UART RX status */
;;;533            UARTx->UART_CON |= RXStatus;
;;;534    		}
;;;535    #endif
;;;536    #endif
;;;537    }
000002  4770              BX       lr
;;;538    
                          ENDP


                          AREA ||i.UART_DMACmd||, CODE, READONLY, ALIGN=1

                  UART_DMACmd PROC
;;;554     */
;;;555    void UART_DMACmd ( UART_TypeDef* UARTx, uint16_t UART_DMAReq, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;556    {
;;;557        /* Check the parameters */
;;;558        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;559        assert_param ( IS_UART_DMAREQ ( UART_DMAReq ) );
;;;560        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;561    
;;;562        if ( NewState != DISABLE )
;;;563        {
;;;564            /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;565               DMAR bits in the UART IDE register */
;;;566            UARTx->UART_IDE |= UART_DMAReq;
;;;567        }
;;;568        else
;;;569        {
;;;570            /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;571               DMAR bits in the UART IDE register */
;;;572            UARTx->UART_IDE &= ( uint16_t ) ~UART_DMAReq;
000002  6902              LDR      r2,[r0,#0x10]
000004  d001              BEQ      |L5.10|
000006  430a              ORRS     r2,r2,r1              ;566
000008  e002              B        |L5.16|
                  |L5.10|
00000a  43c9              MVNS     r1,r1
00000c  b289              UXTH     r1,r1
00000e  400a              ANDS     r2,r2,r1
                  |L5.16|
000010  6102              STR      r2,[r0,#0x10]         ;566
;;;573        }
;;;574    }
000012  4770              BX       lr
;;;575    /* End of UART_Group3.	*/
                          ENDP


                          AREA ||i.UART_DeInit||, CODE, READONLY, ALIGN=2

                  UART_DeInit PROC
;;;56      */
;;;57     void UART_DeInit ( UART_TypeDef* UARTx )
000000  b510              PUSH     {r4,lr}
;;;58     {
000002  4604              MOV      r4,r0
;;;59         assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;60     
;;;61         if ( UARTx == UART0 )
000004  4824              LDR      r0,|L6.152|
000006  4284              CMP      r4,r0
000008  d106              BNE      |L6.24|
;;;62         {
;;;63             /* Enable UART0 reset state */
;;;64             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART0, ENABLE );
00000a  2101              MOVS     r1,#1
00000c  2040              MOVS     r0,#0x40
00000e  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;65             /* Release UART0 from reset state */
;;;66             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART0, DISABLE );
000012  2100              MOVS     r1,#0
000014  2040              MOVS     r0,#0x40
000016  e009              B        |L6.44|
                  |L6.24|
;;;67         }
;;;68         else if ( UARTx == UART1 )
000018  481f              LDR      r0,|L6.152|
00001a  3060              ADDS     r0,r0,#0x60
00001c  4284              CMP      r4,r0
00001e  d108              BNE      |L6.50|
;;;69         {
;;;70             /* Enable UART1 reset state */
;;;71             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART1, ENABLE );
000020  2101              MOVS     r1,#1
000022  2080              MOVS     r0,#0x80
000024  f7fffffe          BL       RCC_APB0PeriphResetCmd
;;;72             /* Release UART1 from reset state */
;;;73             RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART1, DISABLE );
000028  2100              MOVS     r1,#0
00002a  2080              MOVS     r0,#0x80
                  |L6.44|
00002c  f7fffffe          BL       RCC_APB0PeriphResetCmd
000030  e016              B        |L6.96|
                  |L6.50|
;;;74         }
;;;75         else if ( UARTx == UART2 )
000032  481a              LDR      r0,|L6.156|
000034  4284              CMP      r4,r0
000036  d108              BNE      |L6.74|
;;;76         {
;;;77             /* Enable UART2 reset state */
;;;78             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_UART2, ENABLE );
000038  2101              MOVS     r1,#1
00003a  2080              MOVS     r0,#0x80
00003c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;79             /* Release UART2 from reset state */
;;;80             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_UART2, DISABLE );
000040  2100              MOVS     r1,#0
000042  2080              MOVS     r0,#0x80
000044  f7fffffe          BL       RCC_APB1PeriphResetCmd
000048  e00a              B        |L6.96|
                  |L6.74|
;;;81         }
;;;82         else if ( UARTx == UART3 )
00004a  4815              LDR      r0,|L6.160|
00004c  4284              CMP      r4,r0
00004e  d107              BNE      |L6.96|
;;;83         {
;;;84             /* Enable UART3 reset state */
;;;85             RCC_APB2PeriphResetCmd ( RCC_APB2Periph_UART3, ENABLE );
000050  2101              MOVS     r1,#1
000052  2004              MOVS     r0,#4
000054  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;86             /* Release UART3 from reset state */
;;;87             RCC_APB2PeriphResetCmd ( RCC_APB2Periph_UART3, DISABLE );
000058  2100              MOVS     r1,#0
00005a  2004              MOVS     r0,#4
00005c  f7fffffe          BL       RCC_APB2PeriphResetCmd
                  |L6.96|
;;;88         }
;;;89     
;;;90     #if  defined(SC32f12xx)
;;;91         if ( UARTx == UART4 )
000060  480e              LDR      r0,|L6.156|
000062  3060              ADDS     r0,r0,#0x60
000064  4284              CMP      r4,r0
000066  d108              BNE      |L6.122|
;;;92         {
;;;93             /* Enable UART0 reset state */
;;;94             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_UART4, ENABLE );
000068  2101              MOVS     r1,#1
00006a  2040              MOVS     r0,#0x40
00006c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;95             /* Release UART0 from reset state */
;;;96             RCC_APB1PeriphResetCmd ( RCC_APB1Periph_UART4, DISABLE );
000070  2100              MOVS     r1,#0
000072  2040              MOVS     r0,#0x40
000074  f7fffffe          BL       RCC_APB1PeriphResetCmd
                  |L6.120|
;;;97         }
;;;98         else if ( UARTx == UART5 )
;;;99         {
;;;100            /* Enable UART5 reset state */
;;;101            RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART5, ENABLE );
;;;102            /* Release UART5 from reset state */
;;;103            RCC_APB0PeriphResetCmd ( RCC_APB0Periph_UART5, DISABLE );
;;;104        }
;;;105    #endif
;;;106    }
000078  bd10              POP      {r4,pc}
                  |L6.122|
00007a  4807              LDR      r0,|L6.152|
00007c  3080              ADDS     r0,r0,#0x80           ;98
00007e  4284              CMP      r4,r0                 ;98
000080  d1fa              BNE      |L6.120|
000082  1544              ASRS     r4,r0,#21             ;101
000084  2101              MOVS     r1,#1                 ;101
000086  4620              MOV      r0,r4                 ;101
000088  f7fffffe          BL       RCC_APB0PeriphResetCmd
00008c  2100              MOVS     r1,#0                 ;103
00008e  4620              MOV      r0,r4                 ;103
000090  f7fffffe          BL       RCC_APB0PeriphResetCmd
000094  bd10              POP      {r4,pc}
;;;107    
                          ENDP

000096  0000              DCW      0x0000
                  |L6.152|
                          DCD      0x40020020
                  |L6.156|
                          DCD      0x40021020
                  |L6.160|
                          DCD      0x40022020

                          AREA ||i.UART_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  UART_GetFlagStatus PROC
;;;473     */
;;;474    FlagStatus UART_GetFlagStatus ( UART_TypeDef* UARTx, UART_FLAG_TypeDef UART_FLAG )
000000  4602              MOV      r2,r0
;;;475    {
;;;476        ITStatus bitstatus = RESET;
;;;477        /* Check the parameters */
;;;478        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;479        assert_param ( IS_GET_UART_FLAG ( UART_FLAG ) );
;;;480    
;;;481        if ( ( UARTx->UART_STS & UART_FLAG ) != ( uint16_t ) RESET )
000002  6852              LDR      r2,[r2,#4]
000004  2000              MOVS     r0,#0                 ;476
000006  420a              TST      r2,r1
000008  d000              BEQ      |L7.12|
;;;482        {
;;;483            bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L7.12|
;;;484        }
;;;485        else
;;;486        {
;;;487            bitstatus = RESET;
;;;488        }
;;;489        return bitstatus;
;;;490    }
00000c  4770              BX       lr
;;;491    
                          ENDP


                          AREA ||i.UART_ITConfig||, CODE, READONLY, ALIGN=1

                  UART_ITConfig PROC
;;;434     */
;;;435    void UART_ITConfig ( UART_TypeDef* UARTx, uint16_t UART_IT, FunctionalState NewState )
000000  2a00              CMP      r2,#0
;;;436    {
;;;437        /* Check the parameters */
;;;438        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;439        assert_param ( IS_UART_IT ( UART_IT ) );
;;;440        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;441    
;;;442        if ( NewState != DISABLE )
;;;443        {
;;;444            /* Enable the Interrupt sources */
;;;445            UARTx->UART_IDE |= UART_IT;
;;;446        }
;;;447        else
;;;448        {
;;;449            /* Disable the Interrupt sources */
;;;450            UARTx->UART_IDE &= ( uint16_t ) ~UART_IT;
000002  6902              LDR      r2,[r0,#0x10]
000004  d001              BEQ      |L8.10|
000006  430a              ORRS     r2,r2,r1              ;445
000008  e002              B        |L8.16|
                  |L8.10|
00000a  43c9              MVNS     r1,r1
00000c  b289              UXTH     r1,r1
00000e  400a              ANDS     r2,r2,r1
                  |L8.16|
000010  6102              STR      r2,[r0,#0x10]         ;445
;;;451        }
;;;452    }
000012  4770              BX       lr
;;;453    
                          ENDP


                          AREA ||i.UART_Init||, CODE, READONLY, ALIGN=2

                  UART_Init PROC
;;;123     */
;;;124    void UART_Init ( UART_TypeDef* UARTx, UART_InitTypeDef* UART_InitStruct )
000000  b570              PUSH     {r4-r6,lr}
;;;125    {
000002  4604              MOV      r4,r0
;;;126        uint32_t tmpreg;
;;;127        /* Check the parameters */
;;;128        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;129        assert_param ( IS_UART_Mode ( UART_InitStruct->UART_Mode ) );
;;;130    
;;;131        tmpreg = UARTx->UART_CON;
000004  6800              LDR      r0,[r0,#0]
;;;132        tmpreg &= ( uint32_t ) ~ ( UART_CON_SM01 | UART_CON_SM2 );
;;;133        tmpreg |= ( uint32_t ) ( UART_InitStruct->UART_Mode );
000006  688a              LDR      r2,[r1,#8]
000008  08c0              LSRS     r0,r0,#3              ;132
00000a  00c0              LSLS     r0,r0,#3              ;132
00000c  4302              ORRS     r2,r2,r0
;;;134        UARTx->UART_CON = tmpreg;
00000e  6022              STR      r2,[r4,#0]
;;;135    
;;;136        if ( UART_InitStruct->UART_Mode == UART_Mode_8B )
000010  6888              LDR      r0,[r1,#8]
;;;137        {
;;;138            assert_param ( IS_UART_PRESCALER ( UART_InitStruct->UART_BaudRate ) );
;;;139    
;;;140            UARTx->UART_CON &= ~ ( uint32_t ) UART_CON_PERSCALER;
000012  2510              MOVS     r5,#0x10
000014  2800              CMP      r0,#0                 ;136
000016  d00c              BEQ      |L9.50|
000018  c905              LDM      r1!,{r0,r2}           ;125
00001a  4611              MOV      r1,r2                 ;125
;;;141            UARTx->UART_CON |= ( uint32_t ) UART_CON_PERSCALER;
;;;142        }
;;;143        else
;;;144        {
;;;145            tmpreg = ( UART_InitStruct->UART_ClockFrequency / UART_InitStruct->UART_BaudRate );
00001c  f7fffffe          BL       __aeabi_uidivmod
;;;146            if ( tmpreg > 65535 )
000020  4907              LDR      r1,|L9.64|
000022  4288              CMP      r0,r1
000024  d903              BLS      |L9.46|
;;;147            {
;;;148                UARTx->UART_CON |= ( uint32_t ) UART_CON_PERSCALER;
000026  6821              LDR      r1,[r4,#0]
000028  4329              ORRS     r1,r1,r5
00002a  6021              STR      r1,[r4,#0]
;;;149                tmpreg = tmpreg / 16;
00002c  0900              LSRS     r0,r0,#4
                  |L9.46|
;;;150            }
;;;151            UARTx->UART_BAUD = tmpreg;
00002e  60a0              STR      r0,[r4,#8]
;;;152        }
;;;153    }
000030  bd70              POP      {r4-r6,pc}
                  |L9.50|
000032  6820              LDR      r0,[r4,#0]            ;140
000034  43a8              BICS     r0,r0,r5              ;140
000036  6020              STR      r0,[r4,#0]            ;140
000038  6820              LDR      r0,[r4,#0]            ;141
00003a  4328              ORRS     r0,r0,r5              ;141
00003c  6020              STR      r0,[r4,#0]            ;141
00003e  bd70              POP      {r4-r6,pc}
;;;154    
                          ENDP

                  |L9.64|
                          DCD      0x0000ffff

                          AREA ||i.UART_LIN_BKSIZE||, CODE, READONLY, ALIGN=2

                  UART_LIN_BKSIZE PROC
;;;623     */
;;;624    void UART_LIN_BKSIZE ( UART_TypeDef* UARTx, UART_BKSIZE_TypeDef BKSIZE )
000000  4a05              LDR      r2,|L10.24|
;;;625    {
;;;626        uint32_t temp;
;;;627        /* Check the parameters */
;;;628        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;629        assert_param ( IS_UART_BKSIZE ( BKSIZE ) );
;;;630    
;;;631        if ( UARTx == UART2 )
000002  4290              CMP      r0,r2
000004  d107              BNE      |L10.22|
;;;632        {
;;;633            temp = UART2->UART_CON;
000006  4a04              LDR      r2,|L10.24|
000008  3a20              SUBS     r2,r2,#0x20
00000a  6a10              LDR      r0,[r2,#0x20]
;;;634            temp &= ~UART_CON_BKSIZE;
00000c  2301              MOVS     r3,#1
00000e  069b              LSLS     r3,r3,#26
000010  4398              BICS     r0,r0,r3
;;;635            temp |= BKSIZE;
000012  4308              ORRS     r0,r0,r1
;;;636            /**/
;;;637            UART2->UART_CON = temp;
000014  6210              STR      r0,[r2,#0x20]
                  |L10.22|
;;;638        }
;;;639    
;;;640    }
000016  4770              BX       lr
;;;641    
                          ENDP

                  |L10.24|
                          DCD      0x40021020

                          AREA ||i.UART_LIN_LBDL||, CODE, READONLY, ALIGN=2

                  UART_LIN_LBDL PROC
;;;695     */
;;;696    void UART_LIN_LBDL ( UART_TypeDef* UARTx, UART_LBDL_TypeDef LBDL )
000000  4a05              LDR      r2,|L11.24|
;;;697    {
;;;698        uint32_t temp;
;;;699        /* Check the parameters */
;;;700        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;701        assert_param ( IS_UART_LBDL ( LBDL ) );
;;;702    
;;;703        if ( UARTx == UART2 )
000002  4290              CMP      r0,r2
000004  d107              BNE      |L11.22|
;;;704        {
;;;705            temp = UART2->UART_CON;
000006  4a04              LDR      r2,|L11.24|
000008  3a20              SUBS     r2,r2,#0x20
00000a  6a10              LDR      r0,[r2,#0x20]
;;;706            temp &= ~UART_CON_LBDL;
00000c  2301              MOVS     r3,#1
00000e  049b              LSLS     r3,r3,#18
000010  4398              BICS     r0,r0,r3
;;;707            temp |= LBDL;
000012  4308              ORRS     r0,r0,r1
;;;708            UART2->UART_CON = temp;
000014  6210              STR      r0,[r2,#0x20]
                  |L11.22|
;;;709        }
;;;710    
;;;711    
;;;712    
;;;713    
;;;714    }
000016  4770              BX       lr
;;;715    
                          ENDP

                  |L11.24|
                          DCD      0x40021020

                          AREA ||i.UART_LIN_MODE||, CODE, READONLY, ALIGN=2

                  UART_LIN_MODE PROC
;;;599    
;;;600    void UART_LIN_MODE ( UART_TypeDef* UARTx, UART_LINMODE_TypeDef UART_LINMODE )
000000  4a05              LDR      r2,|L12.24|
;;;601    {
;;;602        uint32_t temp;
;;;603        /* Check the parameters */
;;;604        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;605        assert_param ( IS_UART_LINMODE ( UART_LINMODE ) );
;;;606    
;;;607        if ( UARTx == UART2 )
000002  4290              CMP      r0,r2
000004  d106              BNE      |L12.20|
;;;608        {
;;;609            temp = UART2->UART_CON;
000006  4a04              LDR      r2,|L12.24|
000008  3a20              SUBS     r2,r2,#0x20
00000a  6a10              LDR      r0,[r2,#0x20]
;;;610            temp &= ~ ( UART_CON_SLVEN | UART_CON_FUNCSEL );
00000c  4b03              LDR      r3,|L12.28|
00000e  4018              ANDS     r0,r0,r3
;;;611            temp |= UART_LINMODE;
000010  4308              ORRS     r0,r0,r1
;;;612            UART2->UART_CON = temp;
000012  6210              STR      r0,[r2,#0x20]
                  |L12.20|
;;;613        }
;;;614    }
000014  4770              BX       lr
;;;615    /**
                          ENDP

000016  0000              DCW      0x0000
                  |L12.24|
                          DCD      0x40021020
                  |L12.28|
                          DCD      0xfffefeff

                          AREA ||i.UART_LIN_SLVARENE||, CODE, READONLY, ALIGN=2

                  UART_LIN_SLVARENE PROC
;;;660     */
;;;661    void UART_LIN_SLVARENE ( UART_TypeDef* UARTx, FunctionalState NewState )
000000  4a07              LDR      r2,|L13.32|
;;;662    {
;;;663    
;;;664        /* Check the parameters */
;;;665        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;666    
;;;667        if ( UARTx == UART2 )
000002  4290              CMP      r0,r2
000004  d10a              BNE      |L13.28|
;;;668        {
;;;669            if ( NewState != DISABLE )
;;;670            {
;;;671                /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;672                   DMAR bits in the UART IDE register */
;;;673                UART2->UART_CON |= UART_CON_SLVAREN;
000006  4806              LDR      r0,|L13.32|
000008  2201              MOVS     r2,#1
00000a  3820              SUBS     r0,r0,#0x20
00000c  0452              LSLS     r2,r2,#17
00000e  2900              CMP      r1,#0                 ;669
;;;674            }
;;;675            else
;;;676            {
;;;677                /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;678                   DMAR bits in the UART IDE register */
;;;679                UART2->UART_CON &= ( uint32_t ) ~UART_CON_SLVAREN;
000010  6a01              LDR      r1,[r0,#0x20]
000012  d001              BEQ      |L13.24|
000014  4311              ORRS     r1,r1,r2              ;673
000016  e000              B        |L13.26|
                  |L13.24|
000018  4391              BICS     r1,r1,r2
                  |L13.26|
00001a  6201              STR      r1,[r0,#0x20]
                  |L13.28|
;;;680            }
;;;681    
;;;682    
;;;683        }
;;;684    
;;;685    }
00001c  4770              BX       lr
;;;686    
                          ENDP

00001e  0000              DCW      0x0000
                  |L13.32|
                          DCD      0x40021020

                          AREA ||i.UART_PinRemapConfig||, CODE, READONLY, ALIGN=1

                  UART_PinRemapConfig PROC
;;;367     */
;;;368    void UART_PinRemapConfig ( UART_TypeDef* UARTx, UART_PinRemap_TypeDef UART_Remap )
000000  6802              LDR      r2,[r0,#0]
;;;369    {
;;;370        uint32_t tmpreg;
;;;371    
;;;372        /* Check the parameters */
;;;373    #if defined(SC32f10xx)
;;;374        if ( UARTx == UART2 )
;;;375        {
;;;376            tmpreg = UARTx->UART_CON;
;;;377    
;;;378            tmpreg &= ( uint32_t ) ( ~UART_CON_SPOS );
;;;379    
;;;380            tmpreg |= UART_Remap;
;;;381    
;;;382            UARTx->UART_CON = tmpreg;
;;;383        }
;;;384    
;;;385    #elif defined(SC32f12xx)
;;;386        tmpreg = UARTx->UART_CON;
;;;387    
;;;388        tmpreg &= ( uint32_t ) ( ~UART_CON_SPOS );
000002  2303              MOVS     r3,#3
000004  039b              LSLS     r3,r3,#14
000006  439a              BICS     r2,r2,r3
;;;389    
;;;390        tmpreg |= UART_Remap;
000008  430a              ORRS     r2,r2,r1
;;;391    
;;;392        UARTx->UART_CON = tmpreg;
00000a  6002              STR      r2,[r0,#0]
;;;393    #endif
;;;394    }
00000c  4770              BX       lr
;;;395    
                          ENDP


                          AREA ||i.UART_RXCmd||, CODE, READONLY, ALIGN=2

                  UART_RXCmd PROC
;;;220     */
;;;221    void UART_RXCmd ( UART_TypeDef* UARTx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;222    {
;;;223        /* Check the parameters */
;;;224        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;225        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;226    	
;;;227    		/* If it is the programming port UART and no pin mapping has been performed,
;;;228      	   set the RX output to low */
;;;229    #if (UARTOptSwitch)
;;;230    #if defined(SC32f10xx)
;;;231    		if(UARTx == UART0)
;;;232    		{
;;;233    				PC_BIT(2) = 0;
;;;234    				GPIOC->PXCON |= ( uint32_t )0x00000004;
;;;235    		}
;;;236    #elif defined(SC32f12xx)
;;;237    		if((UARTx == UART1) && ((UART1->UART_CON & UART_CON_SPOS) == 0))
;;;238    		{
;;;239    				PA_BIT(15) = 0;
;;;240    				GPIOA->PXCON |= ( uint32_t )0x00008000;
;;;241    		}
;;;242    #endif
;;;243    #endif
;;;244    
;;;245        if ( NewState != DISABLE )
;;;246        {
;;;247            /* Enable the UART RX Function */
;;;248            UARTx->UART_CON |= UART_CON_RXEN;
;;;249        }
;;;250        else
;;;251        {
;;;252            /* Disable the UART RX Function */
;;;253            UARTx->UART_CON &= ( uint16_t ) ~UART_CON_RXEN;
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L15.12|
000006  2240              MOVS     r2,#0x40              ;248
000008  4311              ORRS     r1,r1,r2              ;248
00000a  e001              B        |L15.16|
                  |L15.12|
00000c  4a01              LDR      r2,|L15.20|
00000e  4011              ANDS     r1,r1,r2
                  |L15.16|
000010  6001              STR      r1,[r0,#0]            ;248
;;;254        }
;;;255    }
000012  4770              BX       lr
;;;256    
                          ENDP

                  |L15.20|
                          DCD      0x0000ffbf

                          AREA ||i.UART_ReceiveData||, CODE, READONLY, ALIGN=1

                  UART_ReceiveData PROC
;;;327     */
;;;328    uint16_t UART_ReceiveData ( UART_TypeDef* UARTx )
000000  68c0              LDR      r0,[r0,#0xc]
;;;329    {
;;;330        /* Check the parameters */
;;;331        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;332    
;;;333        /* Receive Data */
;;;334        return ( uint16_t ) ( UARTx->UART_DATA & ( uint16_t ) 0x01FF );
000002  05c0              LSLS     r0,r0,#23
000004  0dc0              LSRS     r0,r0,#23
;;;335    }
000006  4770              BX       lr
;;;336    
                          ENDP


                          AREA ||i.UART_SendBreak||, CODE, READONLY, ALIGN=2

                  UART_SendBreak PROC
;;;645     */
;;;646    void UART_SendBreak()
000000  4803              LDR      r0,|L17.16|
;;;647    {
;;;648        UART2->UART_CON |= UART_CON_BKTR;
000002  6a01              LDR      r1,[r0,#0x20]
000004  2201              MOVS     r2,#1
000006  0612              LSLS     r2,r2,#24
000008  4311              ORRS     r1,r1,r2
00000a  6201              STR      r1,[r0,#0x20]
;;;649    }
00000c  4770              BX       lr
;;;650    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0x40021000

                          AREA ||i.UART_SendData||, CODE, READONLY, ALIGN=1

                  UART_SendData PROC
;;;285     */
;;;286    void UART_SendData ( UART_TypeDef* UARTx, uint16_t Data )
000000  05c9              LSLS     r1,r1,#23
;;;287    {
;;;288        /* Check the parameters */
;;;289        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;290    	
;;;291    #if (UARTOptSwitch)
;;;292    #if defined(SC32f10xx)
;;;293    		if(UARTx == UART0)
;;;294    		{
;;;295    				/* Save the RX status */
;;;296    				RXStatus = UARTx->UART_CON & ( uint16_t ) UART_CON_RXEN;
;;;297    				/* Disable the UART RX Function */
;;;298            UARTx->UART_CON &= ( uint16_t ) ~UART_CON_RXEN;
;;;299    		}
;;;300    #elif defined(SC32f12xx)
;;;301    		if((UARTx == UART1) && ((UART1->UART_CON & UART_CON_SPOS) == 0))
;;;302    		{
;;;303    				/* Save the RX status */
;;;304    				RXStatus = UARTx->UART_CON & ( uint16_t ) UART_CON_RXEN;
;;;305    				/* Disable the UART RX Function */
;;;306            UARTx->UART_CON &= ( uint16_t ) ~UART_CON_RXEN;
;;;307    		}
;;;308    #endif
;;;309    #endif
;;;310    
;;;311        /* Transmit Data */
;;;312        UARTx->UART_DATA = ( Data & ( uint16_t ) 0x01FF );
000002  0dc9              LSRS     r1,r1,#23
000004  60c1              STR      r1,[r0,#0xc]
;;;313    }
000006  4770              BX       lr
;;;314    
                          ENDP


                          AREA ||i.UART_TXCmd||, CODE, READONLY, ALIGN=2

                  UART_TXCmd PROC
;;;170     */
;;;171    void UART_TXCmd ( UART_TypeDef* UARTx, FunctionalState NewState )
000000  2900              CMP      r1,#0
;;;172    {
;;;173        /* Check the parameters */
;;;174        assert_param ( IS_UART_ALL_PERIPH ( UARTx ) );
;;;175        assert_param ( IS_FUNCTIONAL_STATE ( NewState ) );
;;;176    	
;;;177    		/* If it is the programming port UART and no pin mapping has been performed, 
;;;178    			 set the TX output to high */
;;;179    #if (UARTOptSwitch)
;;;180    #if defined(SC32f10xx)
;;;181    		if(UARTx == UART0)
;;;182    		{
;;;183    				PC_BIT(3) = 1;
;;;184    		}
;;;185    #elif defined(SC32f12xx)
;;;186    		if((UARTx == UART1) && ((UART1->UART_CON & UART_CON_SPOS) == 0))
;;;187    		{
;;;188    				PB_BIT(1) = 1;
;;;189    		}
;;;190    #endif
;;;191    #endif
;;;192    
;;;193        if ( NewState != DISABLE )
;;;194        {
;;;195            /* Enable the UART TX Function */
;;;196            UARTx->UART_CON |= UART_CON_TXEN;
;;;197        }
;;;198        else
;;;199        {
;;;200            /* Disable the UART TX Function */
;;;201            UARTx->UART_CON &= ( uint16_t ) ~UART_CON_TXEN;
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L19.12|
000006  2280              MOVS     r2,#0x80              ;196
000008  4311              ORRS     r1,r1,r2              ;196
00000a  e001              B        |L19.16|
                  |L19.12|
00000c  4a01              LDR      r2,|L19.20|
00000e  4011              ANDS     r1,r1,r2
                  |L19.16|
000010  6001              STR      r1,[r0,#0]            ;196
;;;202        }
;;;203    }
000012  4770              BX       lr
;;;204    
                          ENDP

                  |L19.20|
                          DCD      0x0000ff7f

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;795    #if defined (__ARMCC_VERSION)||defined (__ICCARM__)
;;;796    __attribute__((weak)) int fputc ( int c, FILE* f )
000000  b510              PUSH     {r4,lr}
;;;797    {
;;;798        UART_SendData ( Printf_Uart, ( uint8_t ) c );
000002  4b08              LDR      r3,|L20.36|
000004  4604              MOV      r4,r0                 ;797
000006  6819              LDR      r1,[r3,#0]            ;797  ; Printf_Uart
000008  b2c0              UXTB     r0,r0
00000a  60c8              STR      r0,[r1,#0xc]
                  |L20.12|
;;;799        while ( !UART_GetFlagStatus ( Printf_Uart, UART_Flag_TX ) );
00000c  2102              MOVS     r1,#2
00000e  6818              LDR      r0,[r3,#0]  ; Printf_Uart
000010  f7fffffe          BL       UART_GetFlagStatus
000014  2800              CMP      r0,#0
000016  d0f9              BEQ      |L20.12|
000018  6819              LDR      r1,[r3,#0]  ; Printf_Uart
;;;800        UART_ClearFlag ( Printf_Uart, UART_Flag_TX );
00001a  2002              MOVS     r0,#2
00001c  6048              STR      r0,[r1,#4]
;;;801        return c;
00001e  4620              MOV      r0,r4
;;;802    }
000020  bd10              POP      {r4,pc}
;;;803    #elif defined (__GNUC__)
                          ENDP

000022  0000              DCW      0x0000
                  |L20.36|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  Printf_Uart
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\FWLib\\SC32F1XXX_Lib\\src\\sc32f1xxx_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_sc32f1xxx_uart_c_c95a8597____REV16|
#line 463 "..\\CMSIS\\cmsis_armcc.h"
|__asm___16_sc32f1xxx_uart_c_c95a8597____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_sc32f1xxx_uart_c_c95a8597____REVSH|
#line 478
|__asm___16_sc32f1xxx_uart_c_c95a8597____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
